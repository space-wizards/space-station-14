uniform sampler2D SCREEN_TEXTURE;

// Number of frequencies to combine
const highp int N = 32;

uniform highp float spatial_scale; 
uniform highp float strength_scale; 
uniform highp float speed_scale; 
uniform highp mat3 grid_ent_from_viewport_local;

const highp float TWO_PI = 6.28318530718;
const highp float strength_factor = 0.0005;
const highp float spatial_factor = 22.0;

// 1D pseudo-random function
highp float random_1d(highp float n) {
    return fract(sin(n * 12.9898) * 43758.5453);
}

// Kolmogorov amplitude
highp float kolAmp(highp float k) {
    return pow(k, -11.0 / 6.0);
}

void fragment() {
    highp vec2 ps = vec2(1.0/SCREEN_PIXEL_SIZE.x, 1.0/SCREEN_PIXEL_SIZE.y);
    highp float aspectratio = ps.x / ps.y;

    // scale the scale factor with the number of modes
    highp float s_scale = spatial_scale * spatial_factor / sqrt(float(N));

    // Coordinates to use to calculate the effects
    highp vec2 uvW = (grid_ent_from_viewport_local * vec3(UV.x, UV.y, 1.0)).xy;
    uvW *= s_scale;

    highp vec2 grad = vec2(0.0);

    for (lowp int i = 0; i < N; i++) {
        highp float fi = float(i);
        highp float ang = random_1d(fi + 1.0) * TWO_PI;
        highp vec2 dir = vec2(cos(ang), sin(ang));
        highp float k = mix(0.5, 30.0, random_1d(fi + 17.0));
        highp float speed = mix(3., 8., random_1d(fi + 33.0));
        highp float phi_0 = random_1d(fi + 49.0) * TWO_PI;
        highp float t = dot(dir, uvW) * k + TIME * speed * speed_scale + phi_0;

        grad += kolAmp(k) * cos(t) * k * dir;
    }
    grad *= s_scale;

    // Mask calculation
    highp float mask = clamp((zTexture(UV).a - 0.5)*2.0, 0.00, 1.0);

    // Heat strength calculation
    highp float heatStrength = zTexture(UV).r*1.0;
    heatStrength = clamp(-heatStrength*heatStrength + 2.0*heatStrength, 0.0, 1.0);
    highp vec2 uvDist = UV + (strength_scale * strength_factor * heatStrength * mask) * grad;

    // Apply to the texture
    vec4 distorted_color = texture2D(SCREEN_TEXTURE, uvDist);
    
    // --- DEBUGGING MODIFICATION START ---
    // Mix the distorted result with pure Green (0.0, 1.0, 0.0)
    // The 0.5 factor makes it "half" translucent (50% original, 50% green)
    //COLOR = mix(distorted_color, vec4(0.0, 1.0, 0.0, 1.0), 0.5);
    
    // Note: If you want to visualize ONLY the areas where heat is active, 
    // you can swap the line above with this one:
     COLOR = mix(distorted_color, vec4(0.0, 1.0, 0.0, 1.0), 0.5 * mask * heatStrength);
    // --- DEBUGGING MODIFICATION END ---
}