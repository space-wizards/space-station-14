using Content.Client.UserInterface.Controls;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;

namespace Content.Client.Administration.UI.ParrotMemories;

[GenerateTypedNameReferences]
public sealed partial class ParrotMemoryWindow : FancyWindow
{
    public int RoundId { get; private set; }

    private int _memoryCount;

    public ParrotMemoryWindow(int roundId)
    {
        RobustXamlLoader.Load(this);

        RoundId = roundId;
    }

    /// <summary>
    /// Helper function to set a new round on this window
    /// </summary>
    public void SetRound(int newRoundId)
    {
        RoundId = newRoundId;
        RoundLineEdit.Text = RoundId.ToString();
    }

    /// <summary>
    /// Gets the currently active/shown list of memories
    /// </summary>
    public ParrotMemoryList? GetActiveList()
    {
        var currentActiveTab = MemoryTabContainer.CurrentTab;
        var currentActiveChild = MemoryTabContainer.GetChild(currentActiveTab);

        if (currentActiveChild is not ParrotMemoryList { } parrotMemoryList)
            return null;

        return parrotMemoryList;
    }

    /// <summary>
    /// Helper function to set the text of the memory count label
    /// </summary>
    public void UpdateMemoryCountText(int memoryCount)
    {
        _memoryCount = memoryCount;
        MemoryCountLabel.Text = Loc.GetString("parrot-memory-num-memories", ("memoryCount", _memoryCount));
    }

    /// <summary>
    /// Decrements the memory count of the window by a given number. This is here specifically in the case a memory is
    /// blocked
    /// </summary>
    public void DecrementMemoryCount(int i)
    {
        _memoryCount -= i;
        UpdateMemoryCountText(_memoryCount);
    }

    /// <summary>
    /// Sets all or only active lists to dirty so that they receive new memories on refresh
    /// </summary>
    /// <param name="inactiveOnly">Only set inactive lists to dirty. Used when blocking/unblocking memories</param>
    public void SetListsDirty(bool inactiveOnly = false)
    {
        for (var i = 0; i < MemoryTabContainer.ChildCount; i++)
        {
            if (inactiveOnly && i == MemoryTabContainer.CurrentTab)
                continue;

            var child = MemoryTabContainer.GetChild(i);

            if (child is not ParrotMemoryList { Dirty: false } parrotMemoryList)
                continue;

            parrotMemoryList.Dirty = true;
        }
    }

    /// <summary>
    /// Sets the currently active/show list to be dirty so that it receives new memories on refresh
    /// </summary>
    public void SetActiveListDirty()
    {
        if (GetActiveList() is { } parrotMemoryList)
            parrotMemoryList.Dirty = true;
    }
}
