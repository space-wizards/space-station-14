using Content.Client.Administration.Managers;
using Content.Shared.Administration.Managers.Bwoink;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Timing;
using Robust.Shared.Utility;

namespace Content.Client.Administration.UI.Bwoink;

[GenerateTypedNameReferences]
public sealed partial class BwoinkPanel : BoxContainer
{
    public int Unread { get; private set; } = 0;
    public DateTime LastMessage { get; private set; } = DateTime.MinValue;
    private List<string> PeopleTyping { get; set; } = [];
    public event Action<string>? InputTextChanged;
    public event Action<string>? MessageSent;
    private BwoinkChannelPrototype _channel;
    private bool _sendHelpText;

    public BwoinkPanel(BwoinkWindow parentWindow, BwoinkChannelPrototype channel, ClientBwoinkManager clientBwoinkManager, bool sendHelpText)
    {
        RobustXamlLoader.Load(this);
        // TODO: dont use static Loc for this.
        Name = Loc.GetString(channel.Name);

        _channel = channel;
        _sendHelpText = sendHelpText;

        if (sendHelpText)
        {
            var helpText = new FormattedMessage(1);
            helpText.AddMarkupOrThrow(Loc.GetString(channel.HelpText));
            TextOutput.AddMessage(helpText);
        }

        var msg = new FormattedMessage();
        msg.PushColor(Color.LightGray);
        msg.AddText(Loc.GetString("bwoink-system-messages-being-relayed-to-discord"));
        msg.Pop();
        RelayedToDiscordLabel.SetMessage(msg);

        OnVisibilityChanged += c =>
        {
            if (c.Visible)
                Unread = 0;
        };
        SenderLineEdit.OnTextEntered += Input_OnTextEntered;
        SenderLineEdit.OnTextChanged += Input_OnTextChanged;
        UpdateTypingIndicator();
    }


    private void Input_OnTextEntered(LineEdit.LineEditEventArgs args)
    {
        if (string.IsNullOrWhiteSpace(args.Text))
            return;

        MessageSent?.Invoke(args.Text);
        SenderLineEdit.Clear();
    }

    private void Input_OnTextChanged(LineEdit.LineEditEventArgs args)
    {
        InputTextChanged?.Invoke(args.Text);
    }

    public void UpdateAllLines(List<BwoinkMessage> messages)
    {
        TextOutput.Clear();

        if (_sendHelpText)
        {
            // TODO: dont use static Loc for this.
            var helpText = new FormattedMessage(1);
            helpText.AddMarkupOrThrow(Loc.GetString(_channel.HelpText));
            TextOutput.AddMessage(helpText);
        }

        foreach (var message in messages)
        {
            TextOutput.AddMessage(FormatMessage(message));
            LastMessage = message.SentAt;
        }
    }

    public void ReceiveLine(BwoinkMessage message)
    {
        if (!Visible)
            Unread++;


        TextOutput.AddMessage(FormatMessage(message));
        LastMessage = message.SentAt;
    }

    private FormattedMessage FormatMessage(BwoinkMessage message)
    {
        var formatted = new FormattedMessage(1);
        // TODO: Proper name handling.
        // TODO: Escape markdown.
        var color = "white";
        if (message.Flags.HasFlag(MessageFlags.Manager))
            color = "red";

        formatted.AddMarkupOrThrow($"[color=gray]{message.SentAt.ToShortTimeString()}[/color] [color={color}]{message.Sender}[/color] {message.Content}");

        return formatted;
    }

    private void UpdateTypingIndicator()
    {
        var msg = new FormattedMessage();
        msg.PushColor(Color.LightGray);

        var text = PeopleTyping.Count == 0
            ? string.Empty
            : Loc.GetString("bwoink-system-typing-indicator",
                ("players", string.Join(", ", PeopleTyping)),
                ("count", PeopleTyping.Count));

        msg.AddText(text);
        msg.Pop();

        TypingIndicator.SetMessage(msg);
    }

    public void UpdatePlayerTyping(string name, bool typing)
    {
        if (typing)
        {
            if (PeopleTyping.Contains(name))
                return;

            PeopleTyping.Add(name);
            Timer.Spawn(TimeSpan.FromSeconds(10), () =>
            {
                if (Disposed)
                    return;

                PeopleTyping.Remove(name);
                UpdateTypingIndicator();
            });
        }
        else
        {
            PeopleTyping.Remove(name);
        }

        UpdateTypingIndicator();
    }
}
