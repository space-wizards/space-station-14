using System.Linq;
using System.Numerics;
using Content.Client.Administration.Managers;
using Content.Shared.Administration.Managers.Bwoink;
using Robust.Client.AutoGenerated;
using Robust.Client.Player;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;

namespace Content.Client.Administration.UI.Bwoink;

/// <summary>
/// This window connects to a BwoinkSystem channel. BwoinkSystem manages the rest.
/// </summary>
[GenerateTypedNameReferences]
public sealed partial class BwoinkWindow : DefaultWindow
{
    private readonly IPrototypeManager _prototypeManager;
    private readonly IPlayerManager _playerManager;
    private readonly ClientBwoinkManager _bwoinkManager;
    private readonly ILocalizationManager _localizationManager;

    private readonly Dictionary<ProtoId<BwoinkChannelPrototype>, int> _channelIndexes = [];

    public BwoinkWindow(ClientBwoinkManager clientBwoinkManager,
        IPrototypeManager prototypeManager,
        IPlayerManager playerManager,
        ILocalizationManager localizationManager)
    {
        RobustXamlLoader.Load(this);

        _prototypeManager = prototypeManager;
        _playerManager = playerManager;
        _bwoinkManager = clientBwoinkManager;
        _localizationManager = localizationManager;

        Regenerate();
    }

    protected override void EnteredTree()
    {
        base.EnteredTree();
        _bwoinkManager.ReloadedData += Regenerate;
    }

    protected override void ExitedTree()
    {
        base.ExitedTree();
        _bwoinkManager.ReloadedData -= Regenerate;
    }

    public void Regenerate()
    {
        // We now nuke all the channels we already have. This *does* loose us any input and state we have previously.
        // Frankly, I call this a skill issue when admins upload prototypes on live.
        Channels.RemoveAllChildren();
        _channelIndexes.Clear();

        // We ITERATE (rain world reference) all the bwoink channels to see if we can manage any of them
        // if so, we make window biiig
        // if not, we make it smol
        var canManageAny = _prototypeManager.EnumeratePrototypes<BwoinkChannelPrototype>()
            .Any(bwoinkChannelPrototype => _bwoinkManager.CanManageChannel(bwoinkChannelPrototype));

        SetSize = canManageAny ? new Vector2(900, 500) : new Vector2(500, 300);

        var channels = _prototypeManager.EnumeratePrototypes<BwoinkChannelPrototype>();
        var index = 0;
        foreach (var channel in channels.OrderBy(x => x.Order))
        {
            if (!_bwoinkManager.CanReadChannel(channel))
                continue; // cooked

            _channelIndexes[channel.ID] = index;
            index++;

            var canManage = _bwoinkManager.CanManageChannel(channel, _playerManager.LocalSession!);
            if (canManage)
            {
                var control = new BwoinkControl(this, channel, _bwoinkManager, _localizationManager);
                Channels.AddChild(control);
                control.ChannelSelector.StopFiltering();
                control.ChannelSelector.PopulateList();
            }
            else
            {
                var control = new BwoinkPanel(this, channel, _bwoinkManager, false, null, _localizationManager);
                _bwoinkManager.MessageReceived += (sender, args) =>
                {
                    if (sender.Id != channel.ID)
                        return;

                    control.ReceiveLine(args.message);
                };

                // Needed since the bwoinkpanel expects itself to be nested within a "proper" container.
                control.Margin = new Thickness(0.3f);

                if (_bwoinkManager.Conversations[channel].TryGetValue(_playerManager.LocalSession!.UserId, out var existingConvo))
                {
                    control.UpdateAllLines(existingConvo.Messages);
                }

                control.MessageSent += text => _bwoinkManager.SendMessageNonAdmin(channel, text.text);
                Channels.AddChild(control);
            }
        }

        Channels.CurrentTab = 0; // Prevent crashing if the current active tab gets deleted during the reload.
    }


    public void SwitchToChannel(ProtoId<BwoinkChannelPrototype> channel)
    {
        if (!_bwoinkManager.CanReadChannel(channel))
            return;

        Channels.CurrentTab = _channelIndexes[channel];
    }
}
