using System.Linq;
using System.Text;
using Content.Client.Administration.Managers;
using Content.Client.Administration.UI.CustomControls;
using Content.Client.UserInterface.Systems.Bwoink;
using Content.Shared.Administration;
using Content.Shared.Administration.Managers.Bwoink;
using Content.Shared.CCVar;
using Robust.Client.AutoGenerated;
using Robust.Client.Console;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Network;
using Robust.Shared.Configuration;
using Robust.Shared.Prototypes;
using Robust.Shared.Utility;

namespace Content.Client.Administration.UI.Bwoink;

/// <summary>
/// This window connects to a BwoinkSystem channel. BwoinkSystem manages the rest.
/// </summary>
[GenerateTypedNameReferences]
public sealed partial class BwoinkControl : Control
{
    [Dependency] private readonly IClientAdminManager _adminManager = default!;
    [Dependency] private readonly IClientConsoleHost _console = default!;
    [Dependency] private readonly IUserInterfaceManager _ui = default!;
    [Dependency] private readonly IConfigurationManager _cfg = default!;

    private PlayerInfo? _currentPlayer;
    private Dictionary<NetUserId, BwoinkPanel> _panels = new();

    private BwoinkWindow _parentWindow;
    private BwoinkChannelPrototype _channel;
    private ClientBwoinkManager _clientBwoinkManager;

    public BwoinkControl(BwoinkWindow parentWindow, BwoinkChannelPrototype channel, ClientBwoinkManager clientBwoinkManager)
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        // TODO: Dont use static LOC
        Name = Loc.GetString(channel.Name);

        clientBwoinkManager.MessageReceived += MessageReceived;

        _parentWindow = parentWindow;
        _channel = channel;
        _clientBwoinkManager = clientBwoinkManager;

        var newPlayerThreshold = 0;
        _cfg.OnValueChanged(CCVars.NewPlayerThreshold, (val) => { newPlayerThreshold = val; }, true);

        _adminManager.AdminStatusUpdated += UpdateButtons;
        UpdateButtons();

        ChannelSelector.OnSelectionChanged += sel =>
        {
            _currentPlayer = sel;
            SwitchToChannel(sel?.SessionId);
            ChannelSelector.PlayerListContainer.DirtyList();

            if (sel is null)
            {
                parentWindow.Title = Loc.GetString("bwoink-title-none-selected");
                return;
            }

            parentWindow.Title = $"{sel.CharacterName} / {sel.Username} | {Loc.GetString("generic-playtime-title")}: ";

            parentWindow.Title += sel.OverallPlaytime != null ? sel.PlaytimeString : Loc.GetString("generic-unknown-title");
        };

        ChannelSelector.OverrideText += (info, text) =>
        {
            var sb = new StringBuilder();

            if (info.Connected)
                sb.Append(info.ActiveThisRound ? 'âš«' : 'â—');
            else
                sb.Append(info.ActiveThisRound ? 'â­˜' : 'Â·');

            sb.Append(' ');
            var channelProperties = _clientBwoinkManager.GetOrCreatePlayerPropertiesForChannel(_channel.ID, info.SessionId);
            if (channelProperties.Unread > 0)
            {
                if (channelProperties.Unread < 11)
                    sb.Append(new Rune('âž€' + (channelProperties.Unread-1)));
                else
                    sb.Append(new Rune(0x2639)); // â˜¹
                sb.Append(' ');
            }

            // Mark antagonists with symbol
            if (info.Antag && info.ActiveThisRound)
                sb.Append(new Rune(0x1F5E1)); // ðŸ—¡

            // Mark new players with symbol
            if (IsNewPlayer(info, newPlayerThreshold))
                sb.Append(new Rune(0x23F2)); // â²

            sb.AppendFormat("\"{0}\"", text);

            return sb.ToString();
        };

        // <summary>
        // Returns true if the player's overall playtime is under the set threshold
        // </summary>

        ChannelSelector.Comparison = (a, b) =>
        {
            EnsurePanel(a.SessionId);
            EnsurePanel(b.SessionId);
            var ach = _clientBwoinkManager.GetOrCreatePlayerPropertiesForChannel(_channel.ID, a.SessionId);
            var bch = _clientBwoinkManager.GetOrCreatePlayerPropertiesForChannel(_channel.ID, b.SessionId);

            // Pinned players first
            if (a.IsPinned != b.IsPinned)
                return a.IsPinned ? -1 : 1;

            // Then, any chat with unread messages.
            var aUnread = ach.Unread > 0;
            var bUnread = bch.Unread > 0;
            if (aUnread != bUnread)
                return aUnread ? -1 : 1;

            // Then, any chat with recent messages from the current round
            var aRecent = a.ActiveThisRound && ach.LastMessage != DateTime.MinValue;
            var bRecent = b.ActiveThisRound && bch.LastMessage != DateTime.MinValue;
            if (aRecent != bRecent)
                return aRecent ? -1 : 1;

            // Sort by connection status. Disconnected players will be last.
            if (a.Connected != b.Connected)
                return a.Connected ? -1 : 1;

            // Sort connected players by whether they have joined the round, then by New Player status, then by Antag status
            if (a.Connected && b.Connected)
            {
                var aNewPlayer = IsNewPlayer(a, newPlayerThreshold);
                var bNewPlayer = IsNewPlayer(b, newPlayerThreshold);

                //  Players who have joined the round will be listed before players in the lobby
                if (a.ActiveThisRound != b.ActiveThisRound)
                    return a.ActiveThisRound ? -1 : 1;

                //  Within both the joined group and lobby group, new players will be grouped and listed first
                if (aNewPlayer != bNewPlayer)
                    return aNewPlayer ? -1 : 1;

                //  Within all four previous groups, antagonists will be listed first.
                if (a.Antag != b.Antag)
                    return a.Antag ? -1 : 1;
            }

            // Sort disconnected players by participation in the round
            if (!a.Connected && !b.Connected)
            {
                if (a.ActiveThisRound != b.ActiveThisRound)
                    return a.ActiveThisRound ? -1 : 1;
            }

            // Finally, sort by the most recent message.
            return bch.LastMessage.CompareTo(ach.LastMessage);
        };

        Playerpanel.OnPressed += _ =>
        {
            if (_currentPlayer is not null)
                _console.ExecuteCommand($"playerpanel \"{_currentPlayer.Username}\"");
        };

        ChannelSelector.StopFiltering();
        PopulateList();
    }

    private void MessageReceived(ProtoId<BwoinkChannelPrototype> sender, (NetUserId person, BwoinkMessage message) args)
    {
        if (_channel.ID != sender.Id)
            return; // Not our bwoink

        var panel = EnsurePanel(args.person);
        panel.ReceiveLine(args.message);

        OnBwoink(args.person);
    }

    private bool IsNewPlayer(PlayerInfo info, int newPlayerThreshold)
    {
        // Don't show every disconnected player as new, don't show 0-minute players as new if threshold is
        if (newPlayerThreshold <= 0 || info.OverallPlaytime is null && !info.Connected)
            return false;

        return (info.OverallPlaytime is null
                || info.OverallPlaytime < TimeSpan.FromMinutes(newPlayerThreshold));
    }

    public void OnBwoink(NetUserId channel)
    {
        ChannelSelector.PopulateList();
    }

    public BwoinkPanel EnsurePanel(NetUserId user)
    {
        if (_panels.TryGetValue(user, out var panel))
            return panel;

        var newPanel = new BwoinkPanel(_parentWindow, _channel, _clientBwoinkManager, true, user);
        _panels.Add(user, newPanel);
        BwoinkArea.AddChild(newPanel);
        newPanel.Visible = false;
        newPanel.MessageSent += s =>
        {
            _clientBwoinkManager.SendMessageAdmin(_channel, user, s);
        };

        if (_clientBwoinkManager.Conversations[_channel].TryGetValue(user, out var existingConvo))
        {
            newPanel.UpdateAllLines(existingConvo.Messages);
        }
        return newPanel;
    }

    public void UpdateButtons()
    {
        var disabled = _currentPlayer == null;

        Playerpanel.Visible = _adminManager.HasFlag(AdminFlags.Admin);
        Playerpanel.Disabled = !Playerpanel.Visible || disabled;
    }

    private void SwitchToChannel(NetUserId? ch)
    {
        UpdateButtons();

        foreach (var (_, panel) in _panels)
        {
            panel.Visible = false;
        }
        if (ch != null)
        {
            var panel = EnsurePanel(ch.Value);
            panel.Visible = true;
        }
    }

    public void PopulateList()
    {
        // Maintain existing pin statuses
        var pinnedPlayers = ChannelSelector.PlayerInfo.Where(p => p.IsPinned).ToDictionary(p => p.SessionId);

        ChannelSelector.PopulateList();

        // Restore pin statuses
        foreach (var player in ChannelSelector.PlayerInfo)
        {
            if (pinnedPlayers.TryGetValue(player.SessionId, out var pinnedPlayer))
            {
                player.IsPinned = pinnedPlayer.IsPinned;
            }
        }

        UpdateButtons();
    }
}
