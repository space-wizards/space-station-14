using System.Linq;
using System.Text;
using Content.Client.Administration.Managers;
using Content.Shared.Administration;
using Content.Shared.Administration.Managers.Bwoink;
using Content.Shared.Administration.Managers.Bwoink.Features;
using Content.Shared.CCVar;
using Robust.Client.AutoGenerated;
using Robust.Client.Console;
using Robust.Client.Player;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Network;
using Robust.Shared.Configuration;
using Robust.Shared.Prototypes;

namespace Content.Client.Administration.UI.Bwoink;

/// <summary>
/// This window connects to a BwoinkSystem channel. BwoinkSystem manages the rest.
/// </summary>
[GenerateTypedNameReferences]
public sealed partial class BwoinkControl : Control
{
    [Dependency] private readonly IClientAdminManager _adminManager = default!;
    [Dependency] private readonly IClientConsoleHost _console = default!;
    [Dependency] private readonly IConfigurationManager _cfg = default!;
    [Dependency] private readonly IPlayerManager _playerManager = default!;

    private PlayerInfo? _currentPlayer;
    private readonly Dictionary<NetUserId, BwoinkPanel> _panels = new();

    private readonly BwoinkWindow _parentWindow;
    private readonly BwoinkChannelPrototype _channel;
    private readonly ClientBwoinkManager _clientBwoinkManager;
    private readonly ILocalizationManager _localizationManager;

    private int _newPlayerThreshold = 0;
    private readonly List<BwoinkActionRow> _rows = [];

    public BwoinkControl(BwoinkWindow parentWindow, BwoinkChannelPrototype channel, ClientBwoinkManager clientBwoinkManager, ILocalizationManager localizationManager)
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this); // TODO: Remove static ioc.

        Name = localizationManager.GetString(channel.Name);
        _localizationManager = localizationManager;
        _parentWindow = parentWindow;
        _channel = channel;
        _clientBwoinkManager = clientBwoinkManager;

        ChannelSelector.OnSelectionChanged += OnSelectionChanged;

        ChannelSelector.OverrideText += OnChannelSelectorOverrideText;
        ChannelSelector.Comparison = ChannelSelectorComparison;

        foreach (var feature in channel.Features)
        {
            if (feature is not ActionRow row)
                continue;

            var bwoinkRow = new BwoinkActionRow(row,
                _adminManager,
                _localizationManager,
                _console,
                _playerManager.LocalSession!,
                clientBwoinkManager,
                channel);
            _rows.Add(bwoinkRow);
            ActionRowsContainer.AddChild(bwoinkRow);
        }
    }

    private void OnSelectionChanged(PlayerInfo? sel)
    {
        _currentPlayer = sel;
        SwitchToChannel(sel?.SessionId);
        ChannelSelector.PlayerListContainer.DirtyList();

        if (sel is null)
        {
            _parentWindow.Title = _localizationManager.GetString("bwoink-title-none-selected");
            return;
        }

        _parentWindow.Title = $"{sel.CharacterName} / {sel.Username} | {_localizationManager.GetString("generic-playtime-title")}: ";

        _parentWindow.Title += sel.OverallPlaytime != null ? sel.PlaytimeString : _localizationManager.GetString("generic-unknown-title");
        UpdateUnreadHeader();
    }

    private int ChannelSelectorComparison(PlayerInfo a, PlayerInfo b)
    {
        EnsurePanel(a.SessionId);
        EnsurePanel(b.SessionId);
        var ach = _clientBwoinkManager.GetOrCreatePlayerPropertiesForChannel(_channel.ID, a.SessionId);
        var bch = _clientBwoinkManager.GetOrCreatePlayerPropertiesForChannel(_channel.ID, b.SessionId);

        // Pinned players first
        if (a.IsPinned != b.IsPinned)
            return a.IsPinned ? -1 : 1;

        // Then, any chat with unread messages.
        var aUnread = ach.Unread > 0;
        var bUnread = bch.Unread > 0;
        if (aUnread != bUnread)
            return aUnread ? -1 : 1;

        // Then, any chat with recent messages from the current round
        var aRecent = a.ActiveThisRound && ach.LastMessage != DateTime.MinValue;
        var bRecent = b.ActiveThisRound && bch.LastMessage != DateTime.MinValue;
        if (aRecent != bRecent)
            return aRecent ? -1 : 1;

        // Sort by connection status. Disconnected players will be last.
        if (a.Connected != b.Connected)
            return a.Connected ? -1 : 1;

        // Sort connected players by whether they have joined the round, then by New Player status, then by Antag status
        if (a.Connected && b.Connected)
        {
            var aNewPlayer = IsNewPlayer(a, _newPlayerThreshold);
            var bNewPlayer = IsNewPlayer(b, _newPlayerThreshold);

            //  Players who have joined the round will be listed before players in the lobby
            if (a.ActiveThisRound != b.ActiveThisRound)
                return a.ActiveThisRound ? -1 : 1;

            //  Within both the joined group and lobby group, new players will be grouped and listed first
            if (aNewPlayer != bNewPlayer)
                return aNewPlayer ? -1 : 1;

            //  Within all four previous groups, antagonists will be listed first.
            if (a.Antag != b.Antag)
                return a.Antag ? -1 : 1;
        }

        // Sort disconnected players by participation in the round
        if (!a.Connected && !b.Connected)
        {
            if (a.ActiveThisRound != b.ActiveThisRound)
                return a.ActiveThisRound ? -1 : 1;
        }

        // Finally, sort by the most recent message.
        return bch.LastMessage.CompareTo(ach.LastMessage);
    }

    protected override void EnteredTree()
    {
        base.EnteredTree();

        _clientBwoinkManager.MessageReceived += MessageReceived;

        _cfg.OnValueChanged(CCVars.NewPlayerThreshold, OnNewPlayerThresholdChanged, true);

        ChannelSelector.StopFiltering();
        ChannelSelector.PopulateList();
        UpdateUnreadHeader();
    }

    protected override void ExitedTree()
    {
        base.ExitedTree();

        _clientBwoinkManager.MessageReceived -= MessageReceived;

        _cfg.UnsubValueChanged(CCVars.NewPlayerThreshold, OnNewPlayerThresholdChanged);
    }

    private void OnNewPlayerThresholdChanged(int val)
    {
        _newPlayerThreshold = val;
    }

    private string OnChannelSelectorOverrideText(PlayerInfo info, string text)
    {
        var sb = new StringBuilder();

        if (info.Connected)
            sb.Append(info.ActiveThisRound ? '‚ö´' : '‚óê');
        else
            sb.Append(info.ActiveThisRound ? '‚≠ò' : '¬∑');

        sb.Append(' ');
        var channelProperties = _clientBwoinkManager.GetOrCreatePlayerPropertiesForChannel(_channel.ID, info.SessionId);
        if (channelProperties.Unread > 0)
        {
            sb.Append($"{GetUnreadRune(channelProperties.Unread)} ");
        }

        // Mark antagonists with symbol
        if (info.Antag && info.ActiveThisRound)
            sb.Append(new Rune(0x1F5E1)); // üó°

        // Mark new players with symbol
        if (IsNewPlayer(info, _newPlayerThreshold))
            sb.Append(new Rune(0x23F2)); // ‚è≤

        sb.Append($"\"{text}\"");

        return sb.ToString();
    }

    public Rune GetUnreadRune(int unread)
    {
        return unread < 11 ? new Rune('‚ûÄ' + (unread - 1)) : new Rune(0x2639); // ‚òπ
    }

    private void MessageReceived(ProtoId<BwoinkChannelPrototype> sender, (NetUserId person, BwoinkMessage message) args)
    {
        if (_channel.ID != sender.Id)
            return; // Not our bwoink

        var panel = EnsurePanel(args.person);
        panel.ReceiveLine(args.message);

        OnBwoink(args.person);
        UpdateUnreadHeader();
    }

    public void UpdateUnreadHeader()
    {
        var unread = _panels.Keys
            .Select(x => _clientBwoinkManager.GetOrCreatePlayerPropertiesForChannel(_channel, x))
            .Sum(x => x.Unread);

        if (unread == 0)
        {
            Name = _localizationManager.GetString(_channel.Name);
        }
        else
        {
            Name = _localizationManager.GetString("bwoink-channel-header-unread", ("title", _localizationManager.GetString(_channel.Name)), ("unread", GetUnreadRune(unread)));
        }
    }

    /// <summary>
    /// Returns true if the player's overall playtime is under the set threshold
    /// </summary>
    private bool IsNewPlayer(PlayerInfo info, int newPlayerThreshold)
    {
        // Don't show every disconnected player as new, don't show 0-minute players as new if threshold is
        if (newPlayerThreshold <= 0 || info.OverallPlaytime is null && !info.Connected)
            return false;

        return (info.OverallPlaytime is null
                || info.OverallPlaytime < TimeSpan.FromMinutes(newPlayerThreshold));
    }

    public void OnBwoink(NetUserId channel)
    {
        ChannelSelector.PopulateList();
    }

    public BwoinkPanel EnsurePanel(NetUserId user)
    {
        if (_panels.TryGetValue(user, out var panel))
            return panel;

        var newPanel = new BwoinkPanel(_parentWindow, _channel, _clientBwoinkManager, true, user, _localizationManager);
        _panels.Add(user, newPanel);
        BwoinkArea.AddChild(newPanel);
        newPanel.Visible = false;
        newPanel.MessageSent += s =>
        {
            _clientBwoinkManager.SendMessageAdmin(_channel, user, s.text, s.flags);
        };

        if (_clientBwoinkManager.Conversations[_channel].TryGetValue(user, out var existingConvo))
        {
            newPanel.UpdateAllLines(existingConvo.Messages);
        }
        return newPanel;
    }

    private void SwitchToChannel(NetUserId? ch)
    {
        _rows.ForEach(x => x.PlayerInfo = _currentPlayer);

        foreach (var (_, panel) in _panels)
        {
            panel.Visible = false;
        }
        if (ch != null)
        {
            var panel = EnsurePanel(ch.Value);
            panel.Visible = true;
        }

        UpdateUnreadHeader();
    }
}
