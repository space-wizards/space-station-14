using System.Text.RegularExpressions;
using Content.Client.Message;
using Content.Shared.Administration.Logs;
using Content.Shared.CCVar;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Configuration;
using Robust.Shared.Utility;

namespace Content.Client.Administration.UI.Logs.Entries;

[GenerateTypedNameReferences]
public sealed partial class AdminLogEntry : BoxContainer
{
    private readonly IConfigurationManager _cfgManager;

    public SharedAdminLog Log { get; }

    private readonly string _rawMessage;

    public AdminLogEntry(ref SharedAdminLog log)
    {
        _cfgManager = IoCManager.Resolve<IConfigurationManager>();

        RobustXamlLoader.Load(this);

        Log = log;

        _rawMessage = $"{log.Date:HH:mm:ss}: {log.Message}";
        Message.SetMessage(_rawMessage);

        DetailsHeading.OnToggled += DetailsToggled;
    }

    /// <summary>
    /// Sets text to be highlighted from a search result, and renders rich text, or removes all rich text markup.
    /// </summary>
    public void RenderResults(Regex highlightRegex, bool renderRichText, bool removeMarkup)
    {
        var color = _cfgManager.GetCVar(CCVars.AdminLogsHighlightColor);
        var formattedMessage = renderRichText
            ? _rawMessage
            : removeMarkup
                ? FormattedMessage.RemoveMarkupPermissive(_rawMessage)
                : FormattedMessage.EscapeText(_rawMessage);

        // Want to avoid highlighting smaller strings
        if (highlightRegex.ToString().Length > 4)
        {
            try
            {
                formattedMessage = highlightRegex.Replace(formattedMessage, $"[color={color}]$1[/color]", 3);
            }
            catch (RegexMatchTimeoutException)
            {
                // if we time out then don't bother highlighting results
            }
        }

        if (!FormattedMessage.TryFromMarkup(formattedMessage, out var outputMessage))
            return;

        Message.SetMessage(outputMessage);
    }

    /// <summary>
    /// We perform some extra calculations in the dropdown, so we want to render that only when
    /// the dropdown is actually opened.
    /// This also removes itself from the event listener so it doesn't trigger again.
    /// </summary>
    private void DetailsToggled(BaseButton.ButtonToggledEventArgs args)
    {
        if (!args.Pressed || DetailsBody.ChildCount > 0)
            return;
        DetailsBody.AddChild(new AdminLogEntryDetails(Log));
        DetailsHeading.OnToggled -= DetailsToggled;
    }
}
