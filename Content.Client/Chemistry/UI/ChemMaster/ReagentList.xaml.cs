using System.Linq;
using Content.Shared.Chemistry.Components;
using Content.Shared.Chemistry.Reagent;
using Content.Shared.FixedPoint;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;

namespace Content.Client.Chemistry.UI.ChemMaster;

/// <summary>
/// Handles displaying a list of <see cref="ReagentRow" />s with optional
/// sorting and dispense amount button.
/// </summary>
[GenerateTypedNameReferences]
public sealed partial class ReagentList : BoxContainer
{
    [Dependency] private readonly IEntityManager _entMan = default!;
    [Dependency] private readonly IPrototypeManager _protoMan = default!;

    /// <summary>
    /// Invoked with a reagent and quantity when its amount button is pressed.
    /// </summary>
    public event Action<ReagentId, FixedPoint2>? OnRowAmountPressed;

    private readonly Dictionary<ReagentListId, ReagentRow> _reagents = [];
    private readonly List<FixedPoint2> _buttonAmounts;

    /// <summary>
    /// Creates a reagent list with given label and button amount settings.
    /// </summary>
    /// <param name="label">The localized "name" of this reagent list.</param>
    /// <param name="buttonAmounts">
    /// An ordered list of <see cref="FixedPoint2" />s that should be used for amount buttons. Use
    /// <see cref="FixedPoint2.MaxValue" /> to represent transferring as much as possible.
    /// </param>
    /// <param name="emptyText">The localized text to display if there are no reagents to list.</param>
    public ReagentList(string label, List<FixedPoint2> buttonAmounts, string? emptyText = null)
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        EmptyTextLabel.Text = emptyText;
        _buttonAmounts = buttonAmounts;
        ListName.Text = label;

        if (string.IsNullOrEmpty(emptyText))
            EmptyTextLabel.Visible = false;
    }

    /// <summary>
    /// Update the displayed name and volume label of the list. Used for container-based reagent lists.
    /// </summary>
    /// <param name="label">The localized "name" of this reagent list. If null, no change is made.</param>
    /// <param name="currentVolume">The localized text of how many units are present. If null, no change is made.</param>
    public void UpdateLabels(string? label, string? currentVolume)
    {
        if (label is not null)
            ListName.Text = label;
        if (currentVolume is not null)
            VolumeLabel.Text = currentVolume;
    }

    /// <summary>
    /// Updates the reagent list with new data and a given sorting method.
    /// </summary>
    /// <param name="newReagents">A mapping of <see cref="ReagentListId" />s to quantities present.</param>
    /// <param name="sortingType">
    /// The sorting type to be used. If null, the order is whatever enumeration order the dictionary has.
    /// </param>
    /// <remarks>
    /// The sorting is not stable with respect to the previous sorting order. Instead, it's stable with respect to the
    /// "oldest first" sorting order. This is probably fine. Also, technically the oldest first sorting order is not
    /// defined because this isn't an ordered dictionary but. It's fine. Don't worry about it.
    /// </remarks>
    public void Update(Dictionary<ReagentListId, FixedPoint2> newReagents, ChemMasterSortingType? sortingType = null)
    {
        // If we have some sort of text to show, make it visible if there's going to be no reagents
        if (!string.IsNullOrEmpty(EmptyTextLabel.Text))
            EmptyTextLabel.Visible = newReagents.Count == 0;

        // First we find out what's missing in the new list
        var toDelete = _reagents.ExceptBy(newReagents.Keys, x => x.Key);

        // Nix that stuff
        foreach (var (id, row) in toDelete)
        {
            _reagents.Remove(id);
            ReagentContainer.RemoveChild(row);
        }

        var sortedReagents = (sortingType switch
            {
                ChemMasterSortingType.Alphabetical => newReagents.OrderBy(x => GetNameForSorting(x.Key)),
                ChemMasterSortingType.Quantity => newReagents.OrderBy(x => x.Value),
                ChemMasterSortingType.Latest => newReagents.Reverse(), // See remarks.
                _ => newReagents
            })
            .Select((x, i) => (i, x)) // Add on an index for row colors
            .ToList();

        // Now we go through newReagents and update or add rows as needed
        foreach (var (i, (id, quantity)) in sortedReagents)
        {
            var rowColor = i % 2 == 1
                ? Color.FromHex("#1B1B1E")
                : Color.FromHex("#202025");

            // Update the existing one
            if (_reagents.TryGetValue(id, out var reagent))
            {
                reagent.SetQuantity(quantity);
                reagent.SetPositionInParent(i);
                // We have to reset the row color since a new item could've
                // been inserted above us, changing our index's parity.
                reagent.SetRowColor(rowColor);
                continue;
            }

            ReagentPrototype? proto = null;
            var name = Loc.GetString("chem-master-window-unknown-reagent-text");
            if (id.Id?.Prototype is { } protoId
                && _protoMan.TryIndex(protoId, out proto))
            {
                name = proto.LocalizedName;
            }
            else if (id.Uid is { } netId)
            {
                var eUid = _entMan.GetEntity(netId);
                // Leaks identity of whoever's inside the pill bottle I guess.
                // Should be fixed if we add honey I shrunk the kids antag.
                name = _entMan.GetComponent<MetaDataComponent>(eUid).EntityName;
            }

            // New reagent got added, so we make a row and shift it into place
            // If we can't find the reagent prototype this is probably an
            // entity, so we don't show buttons for it.
            var buttons = _buttonAmounts;
            if (proto is null)
                buttons = [];

            var row = new ReagentRow(name, quantity, buttons, proto?.SubstanceColor, rowColor);
            ReagentContainer.AddChild(row);
            _reagents[id] = row;
            // I'll be honest I didn't think we have to set the position here but we do.
            // I suspect it's because we haven't invalidated the arrangement at this point yet?
            row.SetPositionInParent(i);

            // The default fallback shouldn't ever occur since we don't give ReagentId-less entries buttons.
            row.OnAmountPressed += amount => OnRowAmountPressed?.Invoke(id.Id ?? default, amount);
        }

        // Actually reorder the rows.
        ReagentContainer.InvalidateArrange();
    }

    private string GetNameForSorting(ReagentListId entry)
    {
        if (entry.Id is { Prototype: var protoId }
            && _protoMan.TryIndex<ReagentPrototype>(protoId, out var proto))
            return proto.LocalizedName;

        // If this is an entity, we don't care about sorting it. Just... take this empty string.
        return "";
    }
}

/// <summary>
/// Pretend this is a sum type. <see cref="ReagentList" /> only supports showing a list of reagents or a list of
/// entities, and this represents the identifier for either case. At least one property should be non-null!
/// </summary>
public record struct ReagentListId
{
    /// <summary>If not-null, this struct represents a reagent with this <see cref="ReagentId"/>.</summary>
    public readonly ReagentId? Id;

    /// <summary>If not-null, this struct represents an entity with this id.</summary>
    public readonly NetEntity? Uid;

    /// <inheritdoc cref="ReagentListId" />
    public ReagentListId(ReagentId Id)
    {
        this.Id = Id;
    }

    /// <inheritdoc cref="ReagentListId" />
    public ReagentListId(NetEntity Uid)
    {
        this.Uid = Uid;
    }
}
