using System.Linq;
using Content.Shared.Chemistry.Components;
using Content.Shared.Chemistry.Reagent;
using Content.Shared.FixedPoint;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;

namespace Content.Client.Chemistry.UI.ChemMaster;

[GenerateTypedNameReferences]
public sealed partial class ReagentList : BoxContainer
{
    [Dependency] private readonly IPrototypeManager _protoMan = default!;

    public event Action<ReagentId, FixedPoint2>? OnRowAmountPressed;

    private readonly string? _emptyText;
    private readonly Dictionary<ReagentListEntry, ReagentRow> _reagents = [];
    private readonly List<FixedPoint2> _buttonAmounts;

    public ReagentList(string label, List<FixedPoint2> buttonAmounts, string? emptyText = null)
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        _emptyText = emptyText;
        _buttonAmounts = buttonAmounts;
        ListName.Text = label;
    }

    public void UpdateLabels(string? label, string? currentVolume)
    {
        if (label is not null)
            ListName.Text = label;
        if (currentVolume is not null)
            VolumeLabel.Text = currentVolume;
    }

    public void Update(Dictionary<ReagentListEntry, FixedPoint2> newReagents, ChemMasterSortingType? sortingType = null)
    {
        // The label saying the container is empty could be in our list container:
        if (_reagents.Count == 0 && _emptyText is not null)
            ReagentContainer.RemoveAllChildren();

        // For resorting we actually rebuild our rows because uh
        // I can't get in-place reordering to work.
        if (sortingType is not null)
        {
            _reagents.Clear();
            ReagentContainer.RemoveAllChildren();
        }

        // First we find out what's missing in the new list
        var toDelete = _reagents.ExceptBy(newReagents.Keys, x => x.Key);

        // Nix that stuff
        foreach (var (id, row) in toDelete)
        {
            _reagents.Remove(id);
            ReagentContainer.RemoveChild(row);
        }

        var sortedReagents = (sortingType switch
            {
                ChemMasterSortingType.Alphabetical => newReagents.OrderBy(x => GetNameForSorting(x.Key)),
                ChemMasterSortingType.Quantity => newReagents.OrderBy(x => x.Value),
                ChemMasterSortingType.Latest => newReagents.Reverse(),
                _ => newReagents
            })
            .Select((x, i) => (i, x)) // Add on an index for row colors
            .ToList();

        // Now we go through newReagents and update or add rows as needed
        foreach (var (i, (id, quantity)) in sortedReagents)
        {
            var rowColor = i % 2 == 1
                ? Color.FromHex("#1B1B1E")
                : Color.FromHex("#202025");

            // Update the existing one
            if (_reagents.TryGetValue(id, out var reagent))
            {
                reagent.SetQuantity(quantity);
                // We have to reset the row color since a new item could've
                // been inserted above us, changing our index's parity.
                reagent.SetRowColor(rowColor);
                continue;
            }

            ReagentPrototype? proto = null;
            if (id.Id?.Prototype is { } protoId)
                _protoMan.TryIndex(protoId, out proto);

            var name = proto?.LocalizedName ?? Loc.GetString("chem-master-window-unknown-reagent-text");

            // New reagent got added, so we make a row and shift it into place
            // If we can't find the reagent prototype this is probably an
            // entity, so we don't show buttons for it.
            var buttons = _buttonAmounts;
            if (proto is null)
                buttons = [];

            var row = new ReagentRow(name, quantity, buttons, proto?.SubstanceColor, rowColor);
            ReagentContainer.AddChild(row);
            _reagents[id] = row;

            row.SetPositionInParent(i);
            // The default fallback shouldn't ever occur since we don't give ReagentId-less entries buttons.
            row.OnAmountPressed += amount => OnRowAmountPressed?.Invoke(id.Id ?? default, amount);
        }

        if (_reagents.Count == 0 && _emptyText is not null)
            ReagentContainer.AddChild(new Label { Text = _emptyText });
    }

    private string GetNameForSorting(ReagentListEntry entry)
    {
        if (entry.Id is { Prototype: var protoId }
            && _protoMan.TryIndex<ReagentPrototype>(protoId, out var proto))
            return proto.LocalizedName;

        // If this is an entity, we don't care about sorting it. Just... take this empty string.
        return "";
    }
}

public record struct ReagentListEntry(ReagentId? Id, NetEntity? Uid);
