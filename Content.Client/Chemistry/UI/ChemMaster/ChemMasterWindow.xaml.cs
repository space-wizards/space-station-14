using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Numerics;
using Content.Client.Stylesheets;
using Content.Client.UserInterface.Controls;
using Content.Shared.Chemistry.Components;
using Content.Shared.Chemistry.Reagent;
using Content.Shared.FixedPoint;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;
using Robust.Shared.Utility;

namespace Content.Client.Chemistry.UI.ChemMaster;

/// <summary>
/// Client-side UI used to control a <see cref="ChemMasterComponent"/>
/// </summary>
[GenerateTypedNameReferences]
public sealed partial class ChemMasterWindow : FancyWindow
{
    [Dependency] private readonly IEntityManager _entMan = default!;
    [Dependency] private readonly IPrototypeManager _prototypeManager = default!;

    public event Action<(ReagentId Id, FixedPoint2 Amount, bool IsBuffer)>? OnReagentButton;
    public event Action<string>? OnEjectButton;
    public event Action<ChemMasterMode>? OnModeButton;
    public event Action? OnSortButton;
    public event Action<uint>? OnPillButton;
    public event Action<(FixedPoint2 Dosage, uint Count, string Label)>? OnCreatePill;
    public event Action<(FixedPoint2 Dosage, string Label)>? OnCreateBottle;

    private readonly ResPath _pillsRsiPath = new("/Textures/Objects/Specific/Chemistry/pills.rsi");
    private Button[] _pillTypeButtons;

    private readonly string _noContainerText = Loc.GetString("chem-master-window-no-container-loaded-text");

    private readonly ReagentList _bufferReagentList;
    private readonly ReagentList _inputReagentList;
    private readonly ReagentList _outputReagentList;

    // Scale that gets applied to the pill sprites.
    private readonly Vector2 _pillTextureScale = new(1.75f, 1.75f);

    /// <summary>
    /// Create and initialize the chem master UI client-side. Creates the basic layout,
    /// actual data isn't filled in until the server sends data about the chem master.
    /// </summary>
    public ChemMasterWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        LayoutPillButtons();

        PillDosage.InitDefaultButtons();
        PillNumber.InitDefaultButtons();
        BottleDosage.InitDefaultButtons();

        // Ensure label length is within the character limit.
        LabelLineEdit.IsValid = s => s.Length <= ChemMasterComponent.LabelMaxLength;

        Tabs.SetTabTitle(0, Loc.GetString("chem-master-window-input-tab"));
        Tabs.SetTabTitle(1, Loc.GetString("chem-master-window-output-tab"));

        // Initial reagent list setup
        _bufferReagentList = new ReagentList(Loc.GetString("chem-master-window-buffer-label") + " ",
            ChemMasterComponent.ChemMasterAmountOptions,
            Loc.GetString("chem-master-window-buffer-empty-text"));

        _inputReagentList = new ReagentList(_noContainerText, ChemMasterComponent.ChemMasterAmountOptions);

        _outputReagentList = new ReagentList(_noContainerText, []);

        BufferInfo.AddChild(_bufferReagentList);
        InputContainerInfo.AddChild(_inputReagentList);
        OutputContainerInfo.AddChild(_outputReagentList);

        // Register events
        _bufferReagentList.OnRowAmountPressed +=
            args => OnReagentButton?.Invoke((args.Id, args.Amount, true));
        _inputReagentList.OnRowAmountPressed +=
            args => OnReagentButton?.Invoke((args.Id, args.Amount, false));

        InputEjectButton.OnPressed += _ => OnEjectButton?.Invoke(ChemMasterComponent.InputSlotName);
        OutputEjectButton.OnPressed += _ => OnEjectButton?.Invoke(ChemMasterComponent.OutputSlotName);

        BufferTransferButton.OnPressed += _ => OnModeButton?.Invoke(ChemMasterMode.Transfer);
        BufferDiscardButton.OnPressed += _ => OnModeButton?.Invoke(ChemMasterMode.Discard);

        BufferSortButton.OnPressed += _ => OnSortButton?.Invoke();

        // Note that PillNumber has an IsValid that enforces it being positive.
        CreatePillButton.OnPressed += _ =>
            OnCreatePill?.Invoke((PillDosage.Value, (uint)PillNumber.Value, LabelLineEdit.Text));
        CreateBottleButton.OnPressed += _ => OnCreateBottle?.Invoke((BottleDosage.Value, LabelLineEdit.Text));
    }

    [MemberNotNull(nameof(_pillTypeButtons))]
    private void LayoutPillButtons()
    {
        var spriteSys = _entMan.System<SpriteSystem>();

        // Pill type selection buttons, in total there are 20 pills.
        // Pill rsi file should have states named as pill1, pill2, and so on.
        var pillTypeGroup = new ButtonGroup();
        _pillTypeButtons = new Button[ChemMasterComponent.PillTypes];
        for (uint i = 0; i < _pillTypeButtons.Length; i++)
        {
            // For every button decide which stylebase to have
            // Every row has 10 buttons
            var styleBase = StyleBase.ButtonOpenBoth;
            styleBase = i switch
            {
                _ when i % 10 == 0 => StyleBase.ButtonOpenRight,
                _ when i % 10 == 9 => StyleBase.ButtonOpenLeft,
                _ => styleBase,
            };

            // Generate buttons
            var button = new Button
            {
                StyleClasses = { styleBase },
                MaxSize = new Vector2(42, 28),
                Group = pillTypeGroup
            };

            // Generate buttons textures
            var specifier = new SpriteSpecifier.Rsi(_pillsRsiPath, "pill" + (i + 1));
            var pillTypeTexture = new TextureRect
            {
                Texture = spriteSys.Frame0(specifier),
                TextureScale = _pillTextureScale,
                Stretch = TextureRect.StretchMode.KeepCentered,
            };
            button.AddChild(pillTypeTexture);

            // Avoid silly variable capture
            var index = i;
            button.OnPressed += _ => OnPillButton?.Invoke(index);

            _pillTypeButtons[index] = button;
            Grid.AddChild(button);
        }
    }

    /// <summary>
    /// Generate a product label based on reagents in the buffer.
    /// </summary>
    private string GenerateLabel(List<ReagentQuantity> bufferReagents)
    {
        if (bufferReagents.Count == 0)
            return "";

        var reagent = bufferReagents.OrderBy(r => r.Quantity).First().Reagent;
        _prototypeManager.TryIndex(reagent.Prototype, out ReagentPrototype? proto);
        return proto?.LocalizedName ?? "";
    }

    private void UpdateContainerInfo(ReagentList list, ContainerInfo? info)
    {
        // Having Entities versus Reagents is mutually exclusive
        // Technically the UI would display it fine, though.
        if (info?.Entities is { } entities)
        {
            list.Update(entities.ToDictionary(ent => new ReagentListId(ent.Id), ent => ent.Quantity));
        }
        else if (info?.Reagents is { } reagents)
        {
            list.Update(reagents.ToDictionary(r => new ReagentListId(r.Reagent), v => v.Quantity));
        }
        else
        {
            list.Update([]);
            list.SetNameLabel(_noContainerText);
            list.SetVolumeLabel("");
        }

        if (info is not { DisplayName: var name })
            return;

        list.SetNameLabel($"{name}: ");
        list.SetVolumeLabel(info.LocalizedCapacity());
    }

    /// <summary>
    /// Sets up the listing for the input container.
    /// </summary>
    public void SetInputContainerInfo(ContainerInfo? info)
    {
        InputEjectButton.Disabled = info is null;
        UpdateContainerInfo(_inputReagentList, info);
    }

    /// <summary>
    /// Sets up the listing for the output container.
    /// </summary>
    public void SetOutputContainerInfo(ContainerInfo? info)
    {
        OutputEjectButton.Disabled = info is null;
        CreateBottleButton.Disabled = info?.Reagents == null;
        CreatePillButton.Disabled = info?.Entities == null;
        UpdateContainerInfo(_outputReagentList, info);
    }

    /// <summary>
    /// Sets up the actual funny infinite storage buffer.
    /// </summary>
    public void UpdateBuffer(Solution bufferSolution, ChemMasterMode mode, ChemMasterSortingType sortingType)
    {
        BufferTransferButton.Pressed = mode == ChemMasterMode.Transfer;
        BufferDiscardButton.Pressed = mode == ChemMasterMode.Discard;

        // Actual buffer itself
        BufferSortButton.Text = sortingType switch
        {
            ChemMasterSortingType.Alphabetical => Loc.GetString("chem-master-window-sort-type-alphabetical"),
            ChemMasterSortingType.Quantity => Loc.GetString("chem-master-window-sort-type-quantity"),
            ChemMasterSortingType.Latest => Loc.GetString("chem-master-window-sort-type-latest"),
            _ => Loc.GetString("chem-master-window-sort-type-none")
        };

        var reagentDict = bufferSolution.Contents.ToDictionary(r => new ReagentListId(r.Reagent), r => r.Quantity);
        _bufferReagentList.Update(reagentDict, sortingType);

        _bufferReagentList.SetVolumeLabel(ReagentQuantity.LocalizedQuantity(bufferSolution.Volume));
    }

    /// <summary>
    /// Assigns default values to the various pill fields and configures their validation.
    /// </summary>
    public void UpdateDosageFields(Solution buffer,
        ContainerInfo? outputContainerInfo,
        string? outputLabel,
        uint selectedPillType,
        FixedPoint2 pillDosageLimit)
    {
        LabelLineEdit.Text = outputLabel ?? GenerateLabel(buffer.Contents);
        BufferCurrentVolume.Text = " " + ReagentQuantity.LocalizedQuantity(buffer.Volume);

        var remainingCapacity = outputContainerInfo is not null
            ? (outputContainerInfo.MaxVolume - outputContainerInfo.CurrentVolume).Int()
            : 0;
        var holdsReagents = outputContainerInfo?.Reagents != null;
        var pillNumberMax = holdsReagents ? 0 : remainingCapacity;
        var bottleAmountMax = holdsReagents ? remainingCapacity : 0;

        var maxDosage = FixedPoint2.Min(buffer.Volume, pillDosageLimit);
        PillDosage.Value = maxDosage.Int();

        _pillTypeButtons[selectedPillType].Pressed = true;

        PillNumber.IsValid = x => x >= 0 && x <= pillNumberMax;
        PillDosage.IsValid = x => x > 0 && x <= pillDosageLimit;
        BottleDosage.IsValid = x => x >= 0 && x <= bottleAmountMax;

        if (PillNumber.Value > pillNumberMax)
            PillNumber.Value = pillNumberMax;
        if (BottleDosage.Value > bottleAmountMax)
            BottleDosage.Value = bottleAmountMax;

        // Avoid division by zero
        PillNumber.Value = maxDosage > 0
            ? FixedPoint2.Min(buffer.Volume / maxDosage, pillNumberMax).Int()
            : 0;

        BottleDosage.Value = FixedPoint2.Min(bottleAmountMax, buffer.Volume).Int();
    }
}
