using System.Linq;
using Content.Client.Stylesheets;
using Content.Client.UserInterface.Controls;
using Content.Shared.Chemistry.Components;
using Content.Shared.Chemistry.Reagent;
using Content.Shared.Storage;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;
using static Robust.Client.UserInterface.Controls.BoxContainer;

namespace Content.Client.Chemistry.UI;

/// <summary>
/// Client-side UI used to control a <see cref="ReagentDispenserComponent"/>.
/// </summary>
[GenerateTypedNameReferences]
public sealed partial class ReagentDispenserWindow : FancyWindow
{
    [Dependency] private readonly IPrototypeManager _prototypeManager = default!;
    [Dependency] private readonly IEntityManager _entityManager = default!;

    public event Action<ItemStorageLocation>? OnDispenseReagentButtonPressed;
    public event Action<ItemStorageLocation>? OnEjectJugButtonPressed;

    private readonly Dictionary<ItemStorageLocation, ReagentCardControl> _cards = [];

    /// <summary>
    /// Create and initialize the dispenser UI client-side. Creates the basic layout,
    /// actual data isn't filled in until the server sends data about the dispenser.
    /// </summary>
    public ReagentDispenserWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
    }

    /// <summary>
    /// Update the button grid of reagents which can be dispensed.
    /// </summary>
    /// <param name="inventory">Reagents which can be dispensed by this dispenser</param>
    private void UpdateReagentsList(List<ReagentInventoryItem> inventory)
    {
        if (ReagentList == null)
            return;

        // First figure out if any items were removed
        var missing = _cards
            .ExceptBy(inventory.Select(item => item.StorageLocation), card => card.Key);

        foreach (var (location, card) in missing)
        {
            _cards.Remove(location);
            ReagentList.RemoveChild(card);
        }

        // Makes sure the resulting cards stay alphabetical.
        // We also need the index to make sure new items are inserted in
        // the right place (and not the end).
        var sortedInv = inventory
            .OrderBy(item => item.ReagentLabel)
            .Select((item, i) => (item, i));

        // Then go through adding and updating cards as needed.
        foreach (var (item, i) in sortedInv)
        {
            if (_cards.TryGetValue(item.StorageLocation, out var card))
            {
                card.UpdateState(item);
                continue;
            }

            // New inventory item
            var newCard = new ReagentCardControl(item);
            newCard.OnPressed += OnDispenseReagentButtonPressed;
            newCard.OnEjectButtonPressed += OnEjectJugButtonPressed;

            ReagentList.Children.Add(newCard);
            newCard.SetPositionInParent(i);
            _cards[item.StorageLocation] = newCard;
        }
    }

    public void UpdateState(ReagentDispenserBoundUserInterfaceState state)
    {
        UpdateContainerInfo(state.OutputContainer);
        UpdateReagentsList(state.Inventory);
        AmountGrid.ButtonList = state.SelectableAmounts.Select(x => x.ToString()).ToList();

        _entityManager.TryGetEntity(state.OutputContainerEntity, out var outputContainerEnt);
        View.SetEntity(outputContainerEnt);

        // Disable the Clear & Eject button if no beaker
        ClearButton.Disabled = state.OutputContainer is null;
        EjectButton.Disabled = state.OutputContainer is null;

        AmountGrid.Selected = state.SelectedDispenseAmount.ToString();
    }

    /// <summary>
    /// Update the fill state and list of reagents held by the current reagent container, if applicable.
    /// </summary>
    private void UpdateContainerInfo(ContainerInfo? container)
    {
        // In an ideal world this wouldn't rebuild its entire state every state update.
        // But I just rewrote the majority of the ChemMaster UI to do that soooo. It's your turn, reader.
        ContainerInfo.Children.Clear();

        if (container is null)
        {
            ContainerInfoName.Text = "";
            ContainerInfoFill.Text = "";
            ContainerInfo.Children.Add(new Label
                { Text = Loc.GetString("reagent-dispenser-window-no-container-loaded-text") });
            return;
        }

        // Set Name of the container and its fill status (Ex: 44/100)
        ContainerInfoName.Text = container.DisplayName;
        ContainerInfoFill.Text = container.LocalizedCapacity();

        foreach (var (reagent, quantity) in container.Reagents ?? [])
        {
            // Try get to the prototype for the given reagent. This gives us its name.
            var localizedName = _prototypeManager.TryIndex(reagent.Prototype, out ReagentPrototype? p)
                ? p.LocalizedName
                : Loc.GetString("reagent-dispenser-window-reagent-name-not-found-text");

            var nameLabel = new Label { Text = $"{localizedName}: " };
            var quantityLabel = new Label
            {
                Text = ReagentQuantity.LocalizedQuantity(quantity),
                StyleClasses = { StyleNano.StyleClassLabelSecondaryColor },
            };

            ContainerInfo.Children.Add(new BoxContainer
            {
                Orientation = LayoutOrientation.Horizontal,
                Children =
                {
                    nameLabel,
                    quantityLabel,
                }
            });
        }
    }
}
