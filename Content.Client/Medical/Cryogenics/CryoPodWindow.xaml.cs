using System.Linq;
using System.Numerics;
using Content.Client.UserInterface.Controls;
using Content.Shared.Atmos;
using Content.Shared.Chemistry.Reagent;
using Content.Shared.Damage.Components;
using Content.Shared.EntityConditions.Conditions;
using Content.Shared.FixedPoint;
using Content.Shared.Medical.Cryogenics;
using Content.Shared.Temperature;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;
namespace Content.Client.Medical.Cryogenics;

[GenerateTypedNameReferences]
public sealed partial class CryoPodWindow : FancyWindow
{
    [Dependency] private readonly IEntityManager _entityManager = default!;
    [Dependency] private readonly IPrototypeManager _prototypeManager = default!;

    public event Action? OnEjectPressed;
    public event Action<FixedPoint2>? OnInjectPressed;

    public CryoPodWindow()
    {
        IoCManager.InjectDependencies(this);
        RobustXamlLoader.Load(this);
        EjectButton.OnPressed += _ => OnEjectPressed?.Invoke();
        Inject1.OnPressed += _ => OnInjectPressed?.Invoke(1);
        Inject5.OnPressed += _ => OnInjectPressed?.Invoke(5);
        Inject10.OnPressed += _ => OnInjectPressed?.Invoke(10);
        Inject20.OnPressed += _ => OnInjectPressed?.Invoke(20);
    }

    public void Populate(CryoPodUserMessage msg)
    {
        HealthAnalyzer.InvalidateMeasure(); // Workaround for layouting bug.
        InvalidateMeasure();

        // Loading screen
        if (LoadingPlaceHolder.Visible)
        {
            LoadingPlaceHolder.Visible = false;
            Content.Visible = true;
        }

        // Atmosphere
        bool showsPressureWarning = (msg.GasMix.Pressure < Atmospherics.WarningLowPressure);
        bool hasGas = (msg.GasMix.Pressure > Atmospherics.GasMinMoles);
        LowPressureWarning.Visible = showsPressureWarning;
        Pressure.Text = Loc.GetString("gas-analyzer-window-pressure-val-text",
                                      ("pressure", $"{msg.GasMix.Pressure:0.00}"));
        Temperature.Text = Loc.GetString("gas-analyzer-window-not-available");

        if (hasGas)
        {
            var celsius = TemperatureHelpers.KelvinToCelsius(msg.GasMix.Temperature);
            Temperature.Text = Loc.GetString("gas-analyzer-window-temperature-val-text",
                                             ("tempK", $"{msg.GasMix.Temperature:0.0}"),
                                             ("tempC", $"{celsius:0.0}"));
        }

        // Gas mix segmented bar chart
        GasMixChart.Clear();
        GasMixChart.Visible = hasGas;

        if (msg.GasMix.Gases != null)
        {
            var totalGasAmount = msg.GasMix.Gases.Sum(gas => gas.Amount);

            foreach (var gas in msg.GasMix.Gases)
            {
                var color = Color.FromHex($"#{gas.Color}", Color.White);
                var percent = gas.Amount / totalGasAmount * 100;
                var localizedName = Loc.GetString(gas.Name);
                var tooltip = Loc.GetString("gas-analyzer-window-molarity-percentage-text",
                                            ("gasName", localizedName),
                                            ("amount", $"{gas.Amount:0.##}"),
                                            ("percentage", $"{percent:0.#}"));
                GasMixChart.AddEntry(gas.Amount, color, tooltip: tooltip);
            }
        }

        // Health analyzer
        var maybePatient = _entityManager.GetEntity(msg.Health.TargetEntity);
        bool hasPatient = msg.Health.TargetEntity.HasValue;
        bool hasDamage = (hasPatient
             && _entityManager.TryGetComponent(maybePatient, out DamageableComponent? damageable)
             && damageable.TotalDamage > 0);

        NoDamageText.Visible = (hasPatient && !hasDamage);
        HealthAnalyzer.Visible = hasPatient;
        NoPatientText.Visible = !hasPatient;
        EjectButton.Disabled = !hasPatient;

        if (hasPatient)
            HealthAnalyzer.Populate(msg.Health);

        // Reagents
        float? lowestTempRequirement = null;
        ReagentId? lowestTempReagent = null;
        var totalBeakerCapacity = msg.BeakerCapacity ?? 0;
        var availableQuantity = new FixedPoint2();
        var injectingQuantity = new FixedPoint2();
        bool hasBeaker = (msg.Beaker != null);

        ChemicalsChart.Clear();

        if (hasBeaker)
        {
            foreach (var (reagent, quantity) in msg.Beaker!)
            {
                availableQuantity += quantity;

                var reagentProto = _prototypeManager.Index<ReagentPrototype>(reagent.Prototype);
                ChemicalsChart.AddEntry(
                    reagentProto.LocalizedName,
                    (float)quantity,
                    reagentProto.SubstanceColor,
                    tooltip: $"{quantity}u {reagentProto.LocalizedName}"
                );

                var temp = TryFindMaxTemperatureRequirement(reagent);
                if (lowestTempRequirement == null
                    || temp < lowestTempRequirement)
                {
                    lowestTempRequirement = temp;
                    lowestTempReagent = reagent;
                }
            }
        }

        if (msg.Injecting != null)
        {
            foreach (var (_, quantity) in msg.Injecting!)
            {
                injectingQuantity += quantity;
            }

            var injectingText = (injectingQuantity > 1 ? $"{injectingQuantity}u" : "");
            ChemicalsChart.AddEntry(
                injectingText,
                (float)injectingQuantity,
                Color.MediumSpringGreen,
                tooltip: $"Injecting {injectingQuantity}u"
            );
        }

        ChemicalsChart.AddEmptySpace((float)(totalBeakerCapacity - availableQuantity - injectingQuantity));

        bool isBeakerEmpty = (injectingQuantity + availableQuantity == 0);
        NoBeakerText.Visible = !hasBeaker;
        EmptyBeakerText.Visible = (hasBeaker && isBeakerEmpty);
        ChemicalsChart.Visible = (hasBeaker && !isBeakerEmpty);
        Inject1.Disabled = (!hasPatient || availableQuantity < 0.1f);
        Inject5.Disabled = (!hasPatient || availableQuantity <= 1);
        Inject10.Disabled = (!hasPatient || availableQuantity <= 5);
        Inject20.Disabled = (!hasPatient || availableQuantity <= 10);
        ChemicalsRuler.TotalNotches = (int)totalBeakerCapacity;
        ChemicalsRuler2.TotalNotches = (int)totalBeakerCapacity;

        // Temperature warning
        bool showsTemperatureWarning =
            (!showsPressureWarning
             && lowestTempRequirement != null
             && lowestTempRequirement < msg.GasMix.Temperature);

        HighTemperatureWarning.Visible = showsTemperatureWarning;

        if (showsTemperatureWarning)
        {
            var reagentName = _prototypeManager.Index<ReagentPrototype>(lowestTempReagent!.Value.Prototype)
                                               .LocalizedName;
            HighTemperatureWarningText.Text = Loc.GetString("cryo-pod-window-high-temperature-warning",
                ("reagent", reagentName),
                ("temperature", lowestTempRequirement!));
        }
    }

    private float? TryFindMaxTemperatureRequirement(ReagentId reagent)
    {
        var reagentProto = _prototypeManager.Index<ReagentPrototype>(reagent.Prototype);
        if (reagentProto.Metabolisms == null)
            return null;

        float? result = null;

        foreach (var (_, metabolism) in reagentProto.Metabolisms)
        {
            foreach (var effect in metabolism.Effects)
            {
                if (effect.Conditions == null)
                    continue;

                foreach (var condition in effect.Conditions)
                {
                    // If there are multiple temperature conditions in the same reagent (which could hypothetically
                    // happen, although it currently doesn't), we return the lowest max temperature.
                    if (condition is TemperatureCondition tempCondition
                        && float.IsFinite(tempCondition.Max)
                        && (result == null || tempCondition.Max < result))
                    {
                        result = tempCondition.Max;
                    }
                }
            }
        }

        return result;
    }

    public void SetEjectErrorVisible(bool isVisible)
    {
        EjectError.Visible = isVisible;
    }

    protected override Vector2 MeasureOverride(Vector2 availableSize)
    {
        const float antiJiggleSlackSpace = 80;
        var oldSize = DesiredSize;
        // Note that Content is inside of a ScrollContainer, so by default its DesiredSize is ignored.
        Content.Measure(availableSize);
        Content.InvalidateMeasure();
        // We add extra space for FancyWindow decorations.
        var newSize = Content.DesiredSize + new Vector2(10, 50);

        // Reduce how often the height of the window jiggles
        if (newSize.Y < oldSize.Y && newSize.Y + antiJiggleSlackSpace > oldSize.Y)
            newSize.Y = oldSize.Y;

        return newSize;
    }
}
