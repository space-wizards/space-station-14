using Robust.Client.AutoGenerated;
using Robust.Client.Input;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Input;

namespace Content.Client.Options.UI.Tabs;

[GenerateTypedNameReferences]
public sealed partial class CustomCommandBindingControl : BoxContainer, IKeyBindingControl
{
    private static readonly List<(LocId LocId, string Channel)> CustomCommandActionTypes = new()
    {
        ("ui-options-custom-command-binding-action-say", "say "),
        ("ui-options-custom-command-binding-action-emote", "me "),
        ("ui-options-custom-command-binding-action-run", string.Empty),
    };

    private IKeyBinding? _bind1;

    /// <inheritdoc />
    public CustomCommandBindingControl()
    {
        RobustXamlLoader.Load(this);

        foreach (var customCommandActionTypeLocId in CustomCommandActionTypes)
        {
            var optionName = Loc.GetString(customCommandActionTypeLocId.LocId);
            OptionsDropDown.AddItem(optionName);
        }

        OptionsDropDown.OnItemSelected += OnOptionSelected;
        CommandTextEdit.OnFocusExit += OnTextFocusLost;
        BindButton.OnPressed += _ =>
        {
            if(OnBind == null)
                return;
            
            var bindArguments = new CustomCommandBindArguments(Function, Bind1, GetCommandText());
            OnBind(BindButton, bindArguments);
        };
    }

    public IKeyBinding? Bind1
    {
        get => _bind1;
        set
        {
            _bind1 = value;
            if (value != null && value.FunctionCommand != value.Function.FunctionName)
            {
                var text = value.FunctionCommand;
                const string say = "say ";
                const string emote = "me ";

                if (text.StartsWith(say))
                {
                    text = text.Substring(say.Length, text.Length - say.Length);
                    OptionsDropDown.SelectId(0);
                }
                else if (text.StartsWith(emote))
                {
                    text = text.Substring(emote.Length, text.Length - emote.Length);
                    OptionsDropDown.SelectId(1);
                }
                else
                {
                    OptionsDropDown.SelectId(2);
                }

                CommandTextEdit.Text = text;
                CommandTextEdit.ToolTip = text;
            }
        }
    }

    public IKeyBinding? Bind2 { get; set; }

    public bool IsComplete => BindButton.Binding is not null;

    public required BoundKeyFunction Function { get; init; }

    /// <summary> Action to invoke on key binding click. Attaches for both 'option1' and 'option2'. </summary>
    public required Action<GUIBoundKeyEventArgs, IKeyBinding?> ButtonOnKeyBindingDown
    {
        init => BindButton.ButtonOnKeyBindingDown = value;
    }

    /// <summary> Action to invoke on BindButton click. </summary>
    public required Action<BindButton, IKeyBindArguments>? OnBind { private get ; init ; }

    /// <summary> Action to invoke on Reset button click. </summary>
    public required Action OnReset
    {
        init => ResetButton.OnPressed += _ =>
        {
            value();
            Parent?.RemoveChild(this);
        };
    }

    public required Action<IKeyBinding , string>? OnDataChanged { private get; init; }

    /// <inheritdoc />
    public void UpdateBindText()
    {
        BindButton.UpdateText();
    }

    /// <summary>
    /// Update binding data. Should be invoked to keep bind buttons info up to date
    /// after input manager key bindings were updated.
    /// </summary>
    public void UpdateData(IReadOnlyList<IKeyBinding> bindings, bool isModified)
    {
        Bind1 = null;
        if (bindings.Count > 0)
        {
            Bind1 = bindings[0];
        }

        BindButton.Binding = Bind1;
    }

    private void OnOptionSelected(OptionButton.ItemSelectedEventArgs obj)
    {
        OptionsDropDown.SelectId(obj.Id);

        if (Bind1 == null || OnBind == null || string.IsNullOrWhiteSpace(CommandTextEdit.Text))
            return;

        OnDataChanged?.Invoke(Bind1, GetCommandText());

    }

    private string GetCommandText()
    {
        return (CustomCommandActionTypes[OptionsDropDown.SelectedId].Channel + CommandTextEdit.Text).TrimStart();
    }

    private void OnTextFocusLost(LineEdit.LineEditEventArgs obj)
    {
        var commandText = CommandTextEdit.Text;
        CommandTextEdit.ToolTip = commandText;

        if (Bind1 == null || OnBind == null || string.IsNullOrWhiteSpace(commandText))
            return;

        OnDataChanged?.Invoke(Bind1, GetCommandText());
    }

}
