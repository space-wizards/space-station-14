using System.Numerics;
using Content.Shared.Paper;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.RichText;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;

namespace Content.Client.Paper.UI;

[GenerateTypedNameReferences]
public sealed partial class StampWidget : PanelContainer
{
    private StyleBoxTexture? _borderTexture;
    private ShaderInstance? _stampShader;

    /// Imp edit, determines whether stamp noise is applied on the shader
    public bool StampNoise = true;

    public float Orientation
    {
        get => StampedByLabel.Orientation;
        set => StampedByLabel.Orientation = value;
    }

    public StampDisplayInfo StampInfo {
        set {
            // pretty much this whole thing is an imp edit

            var resCache = IoCManager.Resolve<IResourceCache>();
            var prototypes = IoCManager.Resolve<IPrototypeManager>();
            var icon = value.StampLargeIcon;
            var hasIcon = value.HasIcon;

            if (hasIcon)
            {
                var borderImage = resCache.GetResource<TextureResource>(
                        "/Textures/Interface/Paper/paper_stamp_border.svg.96dpi.png");

                if (icon != null)
                {
                    borderImage = resCache.GetResource<TextureResource>(
                            "/Textures/_Impstation/Interface/Paper/Stamps/" + icon + ".png");

                    // make stamps 50% larger to better match the original stamp sizes
                    var width = (int)(borderImage.Texture.Width * 1.5);
                    var height = (int)(borderImage.Texture.Height * 1.5);
                    SetSize = new Vector2(width, height);
                }

                _borderTexture = new StyleBoxTexture { Texture = borderImage };
                _borderTexture.SetPatchMargin(StyleBoxTexture.Margin.All, 7.0f);
                PanelOverride = _borderTexture;
            }
            else
            {
                StampNoise = false;
                StampedByLabel.StampNoise = false;
            }

            if (icon == null)
            {
                StampedByLabel.Text = Loc.GetString(value.StampedName);
                StampedByLabel.FontColorOverride = value.StampedColor;
                ModulateSelfOverride = value.StampedColor;

                var font = prototypes.Index<FontPrototype>("Default");
                if (value.StampFont != null && prototypes.TryIndex<FontPrototype>(value.StampFont, out var stampFont))
                    font = stampFont;

                StampedByLabel.FontOverride = new VectorFont(resCache.GetResource<FontResource>(font.Path), 40);
            }

            _stampShader = prototypes.Index<ShaderPrototype>("PaperStamp").InstanceUnique();
        }
    }

    public StampWidget()
    {
        RobustXamlLoader.Load(this);
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        _stampShader?.SetParameter("objCoord", GlobalPosition * UIScale * new Vector2(1, -1));
        _stampShader?.SetParameter("useStampNoise", StampNoise); // imp
        handle.UseShader(_stampShader);
        handle.SetTransform(GlobalPosition * UIScale, Orientation, Vector2.One);
        base.Draw(handle);

        // Restore a sane transform+shader
        handle.SetTransform(Matrix3x2.Identity);
        handle.UseShader(null);
    }
}
