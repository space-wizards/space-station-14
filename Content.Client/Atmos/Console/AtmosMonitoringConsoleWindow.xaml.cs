using Content.Client.Atmos.Consoles;
using Content.Client.Message;
using Content.Client.Pinpointer.UI;
using Content.Client.Stylesheets;
using Content.Client.UserInterface.Controls;
using Content.Shared.Alert;
using Content.Shared.Atmos.Components;
using Content.Shared.Atmos.Monitor;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Map;
using Robust.Shared.Timing;
using Robust.Shared.Utility;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

namespace Content.Client.Atmos.Console;

[GenerateTypedNameReferences]
public sealed partial class AtmosMonitoringConsoleWindow : FancyWindow
{
    private readonly IEntityManager _entManager;
    private readonly SpriteSystem _spriteSystem;

    private EntityUid? _owner;
    private NetEntity? _trackedEntity;

    public event Action<NetEntity?>? SendFocusChangeMessageAction;

    private bool _autoScrollActive = false;
    private bool _autoScrollAwaitsUpdate = false;

    private const float SilencingDuration = 2.5f;

    public AtmosMonitoringConsoleWindow(AtmosMonitoringConsoleBoundUserInterface userInterface, EntityUid? owner)
    {
        RobustXamlLoader.Load(this);
        _entManager = IoCManager.Resolve<IEntityManager>();
        _spriteSystem = _entManager.System<SpriteSystem>();

        // Pass the owner to nav map
        _owner = owner;
        NavMap.Owner = _owner;

        // Set nav map grid uid
        var stationName = Loc.GetString("atmos-monitoring-window-unknown-location");

        if (_entManager.TryGetComponent<TransformComponent>(owner, out var xform))
        {
            NavMap.MapUid = xform.GridUid;

            // Assign station name      
            if (_entManager.TryGetComponent<MetaDataComponent>(xform.GridUid, out var stationMetaData))
                stationName = stationMetaData.EntityName;

            var msg = new FormattedMessage();
            msg.TryAddMarkup(Loc.GetString("atmos-monitoring-window-station-name", ("stationName", stationName)), out _);

            StationName.SetMessage(msg);
        }

        else
        {
            StationName.SetMessage(stationName);
            NavMap.Visible = false;
        }

        // Set trackable entity selected action
        NavMap.TrackedEntitySelectedAction += SetTrackedEntityFromNavMap;

        // Update nav map
        NavMap.ForceNavMapUpdate();

        // Set tab container headers
        MasterTabContainer.SetTabTitle(0, Loc.GetString("atmos-monitoring-window-tab-pumps"));
        MasterTabContainer.SetTabTitle(1, Loc.GetString("atmos-monitoring-window-tab-mixers"));
        MasterTabContainer.SetTabTitle(2, Loc.GetString("atmos-monitoring-window-tab-filters"));
        MasterTabContainer.SetTabTitle(3, Loc.GetString("atmos-monitoring-window-tab-thermoregulators"));

        // Set UI toggles
        ShowPipeNetwork.OnToggled += _ => OnShowPipeNetworkToggled();

        // Set atmos monitoring message action
        SendFocusChangeMessageAction += userInterface.SendFocusChangeMessage;
    }

    #region Toggle handling

    private void OnShowPipeNetworkToggled()
    {
        if (_owner == null)
            return;

        if (!_entManager.TryGetComponent<AtmosMonitoringConsoleComponent>(_owner.Value, out var console))
            return;

        NavMap.ShowPipeNetwork = ShowPipeNetwork.Pressed;

        foreach (var device in console.AtmosDevices)
        {
            if (ShowPipeNetwork.Pressed)
                AddTrackedEntityToNavMap(device);

            else
                NavMap.TrackedEntities.Remove(device.NetEntity);
        }
    }

    #endregion

    public void UpdateUI
        (EntityCoordinates? consoleCoords,
         AtmosMonitoringConsoleEntry[] pumps,
         AtmosMonitoringConsoleEntry[] mixers,
         AtmosMonitoringConsoleEntry[] filters,
         AtmosMonitoringConsoleEntry[] thermoregulators,
         AtmosFocusDeviceData? focusData)
    {
        if (_owner == null)
            return;

        if (!_entManager.TryGetComponent<AtmosMonitoringConsoleComponent>(_owner.Value, out var console))
            return;

        if (_trackedEntity != focusData?.NetEntity)
        {
            SendFocusChangeMessageAction?.Invoke(_trackedEntity);
            focusData = null;
        }

        // Reset nav map values
        NavMap.TrackedCoordinates.Clear();
        NavMap.TrackedEntities.Clear();

        // Add tracked entities to the nav map
        foreach (var device in console.AtmosDevices)
        {
            if (!NavMap.Visible)
                continue;

            if (_trackedEntity != device.NetEntity)
            {
                // Skip atmos devices if the pipe network is toggled off
                if (!ShowPipeNetwork.Pressed)
                    continue;
            }

            AddTrackedEntityToNavMap(device);
        }

        // Show the monitor location
        var consoleUid = _entManager.GetNetEntity(_owner);

        if (consoleCoords != null && consoleUid != null)
        {
            var texture = _spriteSystem.Frame0(new SpriteSpecifier.Texture(new ResPath("/Textures/Interface/NavMap/beveled_circle.png")));
            var blip = new NavMapBlip(consoleCoords.Value, texture, Color.Cyan, true, false);
            NavMap.TrackedEntities[consoleUid.Value] = blip;
        }

        // Update the nav map
        NavMap.ForceNavMapUpdate();

        // Clear excess children from the tables
        while (PumpsTable.ChildCount > pumps.Length)
            PumpsTable.RemoveChild(PumpsTable.GetChild(PumpsTable.ChildCount - 1));

        while (MixersTable.ChildCount > mixers.Length)
            MixersTable.RemoveChild(MixersTable.GetChild(MixersTable.ChildCount - 1));

        while (FiltersTable.ChildCount > filters.Length)
            FiltersTable.RemoveChild(FiltersTable.GetChild(FiltersTable.ChildCount - 1));

        while (ThermoregulatorsTable.ChildCount > thermoregulators.Length)
            ThermoregulatorsTable.RemoveChild(ThermoregulatorsTable.GetChild(ThermoregulatorsTable.ChildCount - 1));

        // Update all entries in each table
        for (int index = 0; index < pumps.Length; index++)
        {
            var entry = pumps.ElementAt(index);
            UpdateUIEntry(entry, index, PumpsTable, console, focusData);
        }

        for (int index = 0; index < mixers.Length; index++)
        {
            var entry = mixers.ElementAt(index);
            UpdateUIEntry(entry, index, MixersTable, console, focusData);
        }

        for (int index = 0; index < filters.Length; index++)
        {
            var entry = filters.ElementAt(index);
            UpdateUIEntry(entry, index, FiltersTable, console, focusData);
        }

        for (int index = 0; index < thermoregulators.Length; index++)
        {
            var entry = filters.ElementAt(index);
            UpdateUIEntry(entry, index, ThermoregulatorsTable, console, focusData);
        }

        // Auto-scroll re-enable
        if (_autoScrollAwaitsUpdate)
        {
            _autoScrollActive = true;
            _autoScrollAwaitsUpdate = false;
        }
    }

    private void AddTrackedEntityToNavMap(AtmosDeviceNavMapData metaData)
    {
        var data = GetBlipTexture(metaData.Group, metaData.Direction);

        if (data == null)
            return;

        var texture = data.Value.Item1;
        var color = (metaData.Color != null) ? metaData.Color * data.Value.Item2 : data.Value.Item2;
        var coords = _entManager.GetCoordinates(metaData.NetCoordinates);

        if (color == null)
            color = Color.White;

        var selectable = false;
        var blip = new NavMapBlip(coords, _spriteSystem.Frame0(texture), color.Value, _trackedEntity == metaData.NetEntity, selectable, 0.6667f);

        NavMap.TrackedEntities[metaData.NetEntity] = blip;
    }

    private void UpdateUIEntry(AtmosMonitoringConsoleEntry entry, int index, Control table, AtmosMonitoringConsoleComponent console, AtmosFocusDeviceData? focusData = null)
    {
        // Make new UI entry if required
        if (index >= table.ChildCount)
        {
            var newEntryContainer = new AtmosMonitoringEntryContainer(entry.NetEntity, _entManager.GetCoordinates(entry.Coordinates));

            // On click
            newEntryContainer.FocusButton.OnButtonUp += args =>
            {
                var prevTrackedEntity = _trackedEntity;
                if (_trackedEntity == entry.NetEntity)
                {
                    _trackedEntity = null;
                }
                else
                {
                    _trackedEntity = newEntryContainer.NetEntity;
                    NavMap.CenterToCoordinates(_entManager.GetCoordinates(entry.Coordinates));
                }
                // Send message to console that the focus has changed
                SendFocusChangeMessageAction?.Invoke(_trackedEntity);
            };

            // Add the entry to the current table
            table.AddChild(newEntryContainer);
        }

        // Update values and UI elements
        var tableChild = table.GetChild(index);

        if (tableChild is not AtmosMonitoringEntryContainer)
        {
            table.RemoveChild(tableChild);
            UpdateUIEntry(entry, index, table, console, focusData);

            return;
        }
    }

    private void UpdateConsoleTable(AtmosMonitoringConsoleComponent console, Control table, NetEntity? currTrackedEntity, NetEntity? prevTrackedEntity)
    {
        foreach (var child in table.Children)
        {
            if (child is not AtmosMonitoringEntryContainer)
                continue;

            var castAlert = (AtmosMonitoringEntryContainer)child;

            if (castAlert.NetEntity == prevTrackedEntity)
                castAlert.RemoveAsFocus();

            else if (castAlert.NetEntity == currTrackedEntity)
                castAlert.SetAsFocus();

            if (castAlert?.Coordinates == null)
                continue;

            var device = console.AtmosDevices.FirstOrNull(x => x.NetEntity == castAlert.NetEntity);

            if (device == null)
                continue;

            AddTrackedEntityToNavMap(device.Value);
        }
    }

    private void SetTrackedEntityFromNavMap(NetEntity? netEntity)
    {
        if (netEntity == null)
            return;

        if (!_entManager.TryGetComponent<AtmosMonitoringConsoleComponent>(_owner, out var console))
            return;

        _trackedEntity = netEntity;

        if (netEntity != null)
        {
            // Get the scroll position of the selected entity on the selected button the UI
            ActivateAutoScrollToFocus();
        }

        // Send message to console that the focus has changed
        SendFocusChangeMessageAction?.Invoke(_trackedEntity);
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        AutoScrollToFocus();
    }

    private void ActivateAutoScrollToFocus()
    {
        _autoScrollActive = false;
        _autoScrollAwaitsUpdate = true;
    }

    private void AutoScrollToFocus()
    {
        if (!_autoScrollActive)
            return;

        var scroll = MasterTabContainer.Children.ElementAt(MasterTabContainer.CurrentTab) as ScrollContainer;
        if (scroll == null)
            return;

        if (!TryGetVerticalScrollbar(scroll, out var vScrollbar))
            return;

        if (!TryGetNextScrollPosition(out float? nextScrollPosition))
            return;

        vScrollbar.ValueTarget = nextScrollPosition.Value;

        if (MathHelper.CloseToPercent(vScrollbar.Value, vScrollbar.ValueTarget))
            _autoScrollActive = false;
    }

    private bool TryGetVerticalScrollbar(ScrollContainer scroll, [NotNullWhen(true)] out VScrollBar? vScrollBar)
    {
        vScrollBar = null;

        foreach (var child in scroll.Children)
        {
            if (child is not VScrollBar)
                continue;

            var castChild = child as VScrollBar;

            if (castChild != null)
            {
                vScrollBar = castChild;
                return true;
            }
        }

        return false;
    }

    private bool TryGetNextScrollPosition([NotNullWhen(true)] out float? nextScrollPosition)
    {
        nextScrollPosition = null;

        var scroll = MasterTabContainer.Children.ElementAt(MasterTabContainer.CurrentTab) as ScrollContainer;
        if (scroll == null)
            return false;

        var container = scroll.Children.ElementAt(0) as BoxContainer;
        if (container == null || container.Children.Count() == 0)
            return false;

        // Exit if the heights of the children haven't been initialized yet
        if (!container.Children.Any(x => x.Height > 0))
            return false;

        nextScrollPosition = 0;

        foreach (var control in container.Children)
        {
            if (control == null || control is not AtmosMonitoringEntryContainer)
                continue;

            if (((AtmosMonitoringEntryContainer)control).NetEntity == _trackedEntity)
                return true;

            nextScrollPosition += control.Height;
        }

        // Failed to find control
        nextScrollPosition = null;

        return false;
    }

    private (SpriteSpecifier.Texture, Color)? GetBlipTexture(AtmosMonitoringConsoleGroup group, Direction? direction = null)
    {
        (SpriteSpecifier.Texture, Color)? output = null;

        switch (group)
        {
            case AtmosMonitoringConsoleGroup.GasPump:
            case AtmosMonitoringConsoleGroup.GasMixer:
            case AtmosMonitoringConsoleGroup.GasFilter:
                switch (direction)
                {
                    case Direction.North:
                        output = (new SpriteSpecifier.Texture(new ResPath("/Textures/Interface/AtmosMonitoring/pump_north.png")), Color.DarkGray); break;
                    case Direction.South:
                        output = (new SpriteSpecifier.Texture(new ResPath("/Textures/Interface/AtmosMonitoring/pump_south.png")), Color.DarkGray); break;
                    case Direction.East:
                        output = (new SpriteSpecifier.Texture(new ResPath("/Textures/Interface/AtmosMonitoring/pump_east.png")), Color.DarkGray); break;
                    default:
                        output = (new SpriteSpecifier.Texture(new ResPath("/Textures/Interface/AtmosMonitoring/pump_west.png")), Color.DarkGray); break;
                }; break;
            case AtmosMonitoringConsoleGroup.GasValve:
                switch (direction)
                {
                    case Direction.North:
                    case Direction.South:
                        output = (new SpriteSpecifier.Texture(new ResPath("/Textures/Interface/AtmosMonitoring/valve_north_south.png")), Color.DarkGray); break;
                    case Direction.East:
                    default:
                        output = (new SpriteSpecifier.Texture(new ResPath("/Textures/Interface/AtmosMonitoring/valve_east_west.png")), Color.DarkGray); break;
                }; break;
            case AtmosMonitoringConsoleGroup.GasInlet:
                output = (new SpriteSpecifier.Texture(new ResPath("/Textures/Interface/NavMap/beveled_circle.png")), Color.DarkGray); break;
            case AtmosMonitoringConsoleGroup.GasOutlet:
            case AtmosMonitoringConsoleGroup.GasOpening:
                output = (new SpriteSpecifier.Texture(new ResPath("/Textures/Interface/NavMap/beveled_square.png")), Color.DarkGray); break;
            case AtmosMonitoringConsoleGroup.Thermoregulator:
                output = (new SpriteSpecifier.Texture(new ResPath("/Textures/Interface/NavMap/beveled_hexagon.png")), Color.DarkGray); break;
        }

        return output;
    }
}
