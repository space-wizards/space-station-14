using System.Numerics;
using Content.Client.UserInterface.Controls;
using Content.Shared.Audio;
using Content.Shared.Input;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Input;
using Robust.Shared.Utility;
using Robust.Shared.Timing;
using TerraFX.Interop.Xlib;
using Content.Shared.Arcade;

namespace Content.Client.Arcade;

/// <summary>
/// Client UI Window for 'Mine Game' Arcade Machine
/// </summary>
[GenerateTypedNameReferences]
public sealed partial class MineGameArcadeWindow : FancyWindow
{
    [Dependency] private readonly IGameTiming _gameTiming = default!;
    private readonly List<MineGameTile> _gameTiles;
    private TimeSpan _referenceTime;
    private int _boardWidth;
    private int _boardHeight;
    private bool _gameRunning;

    // Standard difficulty modes to display at the top for standard players
    private struct PresetDifficulty(string id, MineGameBoardSettings settings)
    {
        public readonly string Id = id;
        public readonly MineGameBoardSettings Settings = settings;
    }
    private static readonly PresetDifficulty[] PresetDifficulties =
    {
        new("easy", new(new(9, 9), 10)),
        new("medium", new(new(16, 16), 40)),
        new("hard", new(new(30, 16), 99))
    };

    public event Action<MineGameBoardSettings>? OnBoardSettingAction;
    public event Action<MineGameTileAction>? OnTileAction;

    #region Single Tile Control
    private sealed class MineGameTile : ContainerButton
    {
        // There is surely a more efficient way to do this than creating a grid of many buttons, but as of writing
        // the engine doesn't seem to really have built-in support for arbitrary in-UI tile grid rendering
        private readonly MineGameArcadeWindow _owner;
        private readonly AnimatedTextureRect _tileImage;
        private readonly int _i;
        public MineGameTileVisState CurrState;
        private Vector2i Pos => new(_i % _owner._boardWidth, _i / _owner._boardWidth);

        private SpriteSpecifier SpriteSpecifierFromTileState(MineGameTileVisState tileState)
        {
            string state = Enum.GetName(typeof(MineGameTileVisState), tileState)?.ToLower() ?? "mine";
            return new SpriteSpecifier.Rsi(new ResPath("/Textures/Interface/Misc/arcade_minegametile.rsi"), state);
        }
        public void UpdateImage()
        {
            _tileImage.SetFromSpriteSpecifier(SpriteSpecifierFromTileState(CurrState));
        }
        private void OnMineGameTilePressed(ButtonEventArgs _)
        {
            if (CurrState == MineGameTileVisState.Uncleared || CurrState >= MineGameTileVisState.ClearedEmpty)
            {
                // Tile should change for standard single-tile clear, but not chording
                if (CurrState == MineGameTileVisState.Uncleared)
                    CurrState = MineGameTileVisState.ClearedEmpty;

                _owner.OnTileAction?.Invoke(new MineGameTileAction(
                    Pos,
                    MineGameTileActionType.Clear
                ));
            }
        }
        private void PerformAction(MineGameTileActionType type)
        {
            _owner.OnTileAction?.Invoke(new MineGameTileAction(
                Pos,
                type
            ));
            UpdateImage();
        }
        private void TryToggleFlag()
        {
            if (!_owner._gameRunning)
                return;
            if (CurrState == MineGameTileVisState.Uncleared)
            {
                CurrState = MineGameTileVisState.Flagged;
                PerformAction(MineGameTileActionType.Flag);
            }
            else if (CurrState == MineGameTileVisState.Flagged)
            {
                CurrState = MineGameTileVisState.Uncleared;
                PerformAction(MineGameTileActionType.Unflag);
            }
        }
        private void OnMineGameTileKeyPress(GUIBoundKeyEventArgs eventArgs)
        {
            if (!_owner._gameRunning)
                return;
            if (eventArgs.Function == EngineKeyFunctions.UIRightClick)
                TryToggleFlag();
            else if (eventArgs.Function == ContentKeyFunctions.Arcade1)
            {
                TryToggleFlag();
                if (CurrState >= MineGameTileVisState.ClearedEmpty)
                    PerformAction(MineGameTileActionType.Clear);
            }
            UpdateImage();
        }
        public MineGameTile(MineGameArcadeWindow owner, int i)
        {
            _owner = owner;
            _i = i;
            MinSize = new Vector2i(16, 16);

            _tileImage = new AnimatedTextureRect { };
            _tileImage.DisplayRect.Stretch = TextureRect.StretchMode.Scale;
            OnPressed += OnMineGameTilePressed;
            OnKeyBindDown += OnMineGameTileKeyPress;

            UpdateImage();
            AddChild(_tileImage);
        }
    }
    #endregion

    public MineGameArcadeWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        MinSize = new Vector2(300, 300);
        Title = Loc.GetString("minegame-menu-title");

        OnResized += OnResize;

        _gameTiles = new List<MineGameTile>();

        // Set up difficulty options
        foreach (var presetDifficulty in PresetDifficulties)
        {
            var presetNewGameButton = new Button()
            {
                Text = Loc.GetString($"minegame-menu-button-{presetDifficulty.Id}")
            };
            presetNewGameButton.OnPressed += _ => OnBoardSettingAction?.Invoke(presetDifficulty.Settings);
            BoardOptionsPresetsContainer.AddChild(presetNewGameButton);
        }
        ToggleCustomOptionsMenuButton.SetPositionLast();

        // (Toggleable visibility) Inputs for custom board width, height, mines
        ToggleCustomOptionsMenuButton.OnPressed += _ =>
        {
            CustomBoardOptionsContainer.Visible = !CustomBoardOptionsContainer.Visible;
        };
        ApplyCustomBoardButton.OnPressed += _ =>
        {
            int.TryParse(CustomWidthField.Text.ToString(), out var customWidth);
            int.TryParse(CustomHeightField.Text.ToString(), out var customHeight);
            int.TryParse(CustomMinesField.Text.ToString(), out var customMines);
            MineGameBoardSettings settings = new(
                new(customWidth, customHeight),
                customMines
            );
            OnBoardSettingAction?.Invoke(settings);
        };
    }

    /// <summary>
    /// Updates game board with new, complete board/game visual state information
    /// </summary>
    public void UpdateBoard(int boardWidth, MineGameTileVisState[] tileStates, MineGameMetadata? metadata)
    {
        if (metadata != null)
        {
            _referenceTime = metadata.ReferenceTime;
            _gameRunning = metadata.Running;
            MineCountLabel.Text = metadata.RemainingMines.ToString();
        }
        BoardGrid.Columns = boardWidth;
        int newBoardHeight = tileStates.Length / boardWidth;
        bool fixSize = _boardWidth != boardWidth || _boardHeight != newBoardHeight;
        _boardWidth = boardWidth;
        _boardHeight = newBoardHeight;

        for (var i = _gameTiles.Count; i < tileStates.Length; ++i)
        {
            // Add new tiles if we don't have enough pooled.
            var newTile = new MineGameTile(this, i);
            _gameTiles.Add(newTile);
            BoardGrid.AddChild(newTile);
        }
        for (var i = 0; i < tileStates.Length; ++i)
        {
            // Update state of existing tiles
            if (tileStates[i] != MineGameTileVisState.None)
            {
                _gameTiles[i].CurrState = tileStates[i];
                _gameTiles[i].UpdateImage();
            }
            _gameTiles[i].Visible = true;
        }
        for (var i = tileStates.Length; i < _gameTiles.Count; ++i)
        {
            // Hide any extra pooled tiles
            _gameTiles[i].Visible = false;
        }

        if (fixSize)
            OnResize();
    }
    protected override void Draw(DrawingHandleScreen handle)
    {
        base.Draw(handle);

        if (_gameRunning)
        {
            var elapsedTime = _gameTiming.CurTime.Subtract(_referenceTime);
            TimeLabel.Text = elapsedTime.ToString("m\\:ss");
        }
        else
        {
            TimeLabel.Text = _referenceTime.ToString("m\\:ss");
        }
    }

    private void OnResize()
    {
        // Couldn't figure out another way to create a grid with scaling and evenly spaced (on both dims) children
        // Thus, the approximate size of each game tile is calculated manually and updated in this window resize hook
        Vector2 containerSize = new Vector2(ContentsContainer.Width, BoardGrid.Height);
        float sz = 16.0f;
        if (containerSize.X > containerSize.Y * _boardWidth / _boardHeight)
        {
            // excess width, constrain by height
            sz = containerSize.Y / _boardHeight;
        }
        else
        {
            // excess height, constrain by width
            sz = containerSize.X / _boardWidth;
        }
        sz *= .95f; // just in case; if resizing loop doesn't fire often enough ui can make tiles go off-ui a little
        Vector2 vecSz = new(sz, sz);
        foreach (var gameTile in _gameTiles)
        {
            gameTile.MinSize = gameTile.SetSize = vecSz;
        }
    }
}
