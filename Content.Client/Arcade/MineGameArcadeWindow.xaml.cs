using System.Numerics;
using Content.Client.UserInterface.Controls;
using Content.Shared.Input;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Input;
using Robust.Shared.Utility;
using Robust.Shared.Timing;
using Content.Shared.Arcade;

namespace Content.Client.Arcade;

/// <summary>
/// Client UI Window for 'Mine Game' Arcade Machine
/// </summary>
[GenerateTypedNameReferences]
public sealed partial class MineGameArcadeWindow : FancyWindow
{
    [Dependency] private readonly IGameTiming _gameTiming = default!;
    private readonly List<MineGameTile> _gameTiles;
    private List<Button> _presetDifficultyButtons;
    private TimeSpan _referenceTime;
    private MineGameBoardSettings _boardSettings;
    private bool _gameRunning;

    public event Action<MineGameBoardSettings>? OnBoardSettingAction;
    public event Action<MineGameTileAction>? OnTileAction;

    #region Single Tile Control
    private sealed class MineGameTile : ContainerButton
    {
        // There is surely a more efficient way to do this than creating a grid of many buttons, but as of writing
        // the engine doesn't seem to really have built-in support for arbitrary in-UI tile grid rendering
        private readonly MineGameArcadeWindow _owner;
        private readonly AnimatedTextureRect _tileImage;
        private readonly int _i;
        public MineGameTileVisState CurrState;
        private Vector2i Pos => new(_i % _owner._boardSettings.BoardSize.X, _i / _owner._boardSettings.BoardSize.X);

        private SpriteSpecifier SpriteSpecifierFromTileState(MineGameTileVisState tileState)
        {
            string state = Enum.GetName(typeof(MineGameTileVisState), tileState)?.ToLower() ?? "mine";
            return new SpriteSpecifier.Rsi(new ResPath("/Textures/Interface/Misc/arcade_minegametile.rsi"), state);
        }
        public void UpdateImage()
        {
            _tileImage.SetFromSpriteSpecifier(SpriteSpecifierFromTileState(CurrState));
        }
        private void OnMineGameTilePressed(ButtonEventArgs _)
        {
            if (CurrState == MineGameTileVisState.Uncleared || CurrState >= MineGameTileVisState.ClearedEmpty)
            {
                _owner.OnTileAction?.Invoke(new MineGameTileAction(
                    Pos,
                    MineGameTileActionType.Clear
                ));
            }
        }
        private void PerformAction(MineGameTileActionType type)
        {
            _owner.OnTileAction?.Invoke(new MineGameTileAction(
                Pos,
                type
            ));
            UpdateImage();
        }
        private void TryToggleFlag()
        {
            if (CurrState == MineGameTileVisState.Uncleared)
            {
                PerformAction(MineGameTileActionType.Flag);
            }
            else if (CurrState == MineGameTileVisState.Flagged)
            {
                PerformAction(MineGameTileActionType.Unflag);
            }
        }
        private void OnMineGameTileKeyPress(GUIBoundKeyEventArgs eventArgs)
        {
            if (eventArgs.Function == EngineKeyFunctions.UIRightClick)
                TryToggleFlag();
            else if (eventArgs.Function == ContentKeyFunctions.Arcade1)
            {
                TryToggleFlag();
                if (CurrState >= MineGameTileVisState.ClearedEmpty)
                    PerformAction(MineGameTileActionType.Clear);
            }
            UpdateImage();
        }
        public MineGameTile(MineGameArcadeWindow owner, int i)
        {
            _owner = owner;
            _i = i;
            MinSize = new Vector2i(16, 16);

            _tileImage = new AnimatedTextureRect { };
            _tileImage.DisplayRect.Stretch = TextureRect.StretchMode.Scale;
            OnPressed += OnMineGameTilePressed;
            OnKeyBindDown += OnMineGameTileKeyPress;

            UpdateImage();
            AddChild(_tileImage);
        }
    }
    #endregion

    public MineGameArcadeWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        MinSize = new Vector2(300, 300);
        Title = Loc.GetString("minegame-menu-title");

        OnResized += OnResize;

        _gameTiles = new List<MineGameTile>();
        _presetDifficultyButtons = new List<Button>();

        // (Toggleable visibility) Inputs for custom board width, height, mines
        ToggleCustomOptionsMenuButton.OnPressed += _ =>
        {
            CustomBoardOptionsContainer.Visible = !CustomBoardOptionsContainer.Visible;
        };
        ApplyCustomBoardButton.OnPressed += _ =>
        {
            int.TryParse(CustomWidthField.Text.ToString(), out var customWidth);
            int.TryParse(CustomHeightField.Text.ToString(), out var customHeight);
            int.TryParse(CustomMinesField.Text.ToString(), out var customMines);
            MineGameBoardSettings settings = new();
            settings.BoardSize = new(customWidth, customHeight);
            settings.MineCount = customMines;
            OnBoardSettingAction?.Invoke(settings);
        };
    }

    public void LoadPresetDifficulties(Dictionary<string, MineGameBoardSettings> presetDifficulties)
    {
        foreach (var button in _presetDifficultyButtons)
        {
            BoardOptionsPresetsContainer.RemoveChild(button);
        }
        _presetDifficultyButtons = new List<Button>();

        // Set up difficulty options
        foreach (var presetDifficulty in presetDifficulties)
        {
            var presetNewGameButton = new Button()
            {
                Text = Loc.GetString($"minegame-menu-button-{presetDifficulty.Key}")
            };
            presetNewGameButton.OnPressed += _ => OnBoardSettingAction?.Invoke(presetDifficulty.Value);
            BoardOptionsPresetsContainer.AddChild(presetNewGameButton);
            _presetDifficultyButtons.Add(presetNewGameButton);
        }
        ToggleCustomOptionsMenuButton.SetPositionLast();
    }

    /// <summary>
    /// Updates game board with new, complete board/game visual state information
    /// </summary>
    public void UpdateBoard(MineGameArcadeComponent component)
    {
        _referenceTime = component.ReferenceTime;
        var currSettings = _boardSettings;
        _boardSettings = component.BoardSettings;
        _boardSettings.BoardSize.X = Math.Max(_boardSettings.BoardSize.X, 1);
        _boardSettings.BoardSize.Y = Math.Max(_boardSettings.BoardSize.Y, 1);

        BoardGrid.Columns = _boardSettings.BoardSize.X;
        bool shouldFixSize = _boardSettings.BoardSize.X != currSettings.BoardSize.X || _boardSettings.BoardSize.Y != currSettings.BoardSize.Y;

        var tileStates = component.TileVisState;
        if (_boardSettings.BoardSize.X == 1)
        {
            tileStates = new MineGameTileVisState[1, 1];
        }
        for (var i = _gameTiles.Count; i < tileStates.Length; ++i)
        {
            // Add new tiles if we don't have enough pooled.
            var newTile = new MineGameTile(this, i);
            _gameTiles.Add(newTile);
            BoardGrid.AddChild(newTile);
        }

        bool boardHasClearedTile = false;
        int flagCount = 0;
        for (var i = 0; i < tileStates.Length; ++i)
        {
            // Update state of existing tiles
            var state = tileStates[i % _boardSettings.BoardSize.X, i / _boardSettings.BoardSize.X];
            if (state != MineGameTileVisState.None)
            {
                _gameTiles[i].CurrState = state;
                _gameTiles[i].UpdateImage();
            }

            if (state >= MineGameTileVisState.ClearedEmpty)
            {
                boardHasClearedTile = true;
            }

            if (state == MineGameTileVisState.Flagged)
            {
                flagCount++;
            }
            _gameTiles[i].Visible = true;
        }
        for (var i = tileStates.Length; i < _gameTiles.Count; ++i)
        {
            // Hide any extra pooled tiles
            _gameTiles[i].Visible = false;
        }

        _gameRunning = boardHasClearedTile && !(component.GameWon || component.GameLost);
        MineCountLabel.Text = (_boardSettings.MineCount - flagCount).ToString();

        if (shouldFixSize)
            OnResize();
    }
    protected override void Draw(DrawingHandleScreen handle)
    {
        base.Draw(handle);

        if (_gameRunning)
        {
            var elapsedTime = _gameTiming.CurTime.Subtract(_referenceTime);
            TimeLabel.Text = elapsedTime.ToString("m\\:ss");
        }
        else
        {
            TimeLabel.Text = _referenceTime.ToString("m\\:ss");
        }
    }

    private void OnResize()
    {
        // Couldn't figure out another way to create a grid with scaling and evenly spaced (on both dims) children
        // Thus, the approximate size of each game tile is calculated manually and updated in this window resize hook
        Vector2 containerSize = new Vector2(ContentsContainer.Width, BoardGrid.Height);
        float sz = 16.0f;
        if (containerSize.X > containerSize.Y * _boardSettings.BoardSize.X / _boardSettings.BoardSize.Y)
        {
            // excess width, constrain by height
            sz = containerSize.Y / _boardSettings.BoardSize.Y;
        }
        else
        {
            // excess height, constrain by width
            sz = containerSize.X / _boardSettings.BoardSize.X;
        }
        sz *= .95f; // just in case; if resizing loop doesn't fire often enough ui can make tiles go off-ui a little
        Vector2 vecSz = new(sz, sz);
        foreach (var gameTile in _gameTiles)
        {
            gameTile.MinSize = gameTile.SetSize = vecSz;
        }
    }
}
