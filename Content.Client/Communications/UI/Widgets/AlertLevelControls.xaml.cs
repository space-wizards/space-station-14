using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;

namespace Content.Client.Communications.UI.Widgets;

[GenerateTypedNameReferences]
public sealed partial class AlertLevelControls : BoxContainer
{
    [Dependency] private readonly ILocalizationManager _loc = default!;
    private bool _alertLevelSelectable;
    private string _currentAlertLevel = string.Empty;

    public event Action<string>? OnAlertLevelChanged;

    public AlertLevelControls()
    {
        IoCManager.InjectDependencies(this);
        RobustXamlLoader.Load(this);

        AlertLevelSelector.OnItemSelected += args =>
        {
            AlertLevelSelector.Select(args.Id);
            EnableDisableConfirmLevelChangeButton();
        };

        ConfirmAlertLevelButton.OnPressed += _ =>
        {
            var metadata = AlertLevelSelector.GetItemMetadata(AlertLevelSelector.SelectedId);
            if (metadata is string cast)
            {
                OnAlertLevelChanged?.Invoke(cast);
            }
        };

        AlertLevelSelector.Disabled = !_alertLevelSelectable;
    }

    /// <summary>
    /// Updates the UI components to display the current alert level and the
    /// selectable alert levels
    /// </summary>
   public void UpdateAlertLevels(List<string>? alerts,
        string currentAlert,
        Color currentAlertColor,
        bool alertLevelSelectable)
    {
        _alertLevelSelectable = alertLevelSelectable;
        _currentAlertLevel = currentAlert;
        CurrentAlertLevelLabel.Text = GetLocalizedAlertName(currentAlert);
        CurrentAlertLevelLabel.ModulateSelfOverride = currentAlertColor;

        AlertLevelSelector.Disabled = alerts == null || !_alertLevelSelectable;

        // If user had changed the selection, but hadn't pressed the confirm
        // button at  the point we received an update message, we want to
        // remember what they had selected, so we can attempt to re-select it
        // if it's still an option in the new set of alert level possibilities.
        string? previousSelection = null;
        if (AlertLevelSelector.ItemCount > 1)
        {
            var metadata = AlertLevelSelector.GetItemMetadata(AlertLevelSelector.SelectedId);
            if (metadata is string cast)
            {
                previousSelection = cast;
            }
        }

        // The server will only send alert levels which are selectable, but
        // unfortunately, for a short time after changing the alert level, no
        // level is selectable, so we won't have any levels to put into the
        // alert level list. Here, we make a dummy item to handle that; this
        // item also informs the user what this combo box is for.
        AlertLevelSelector.Clear();
        AlertLevelSelector.AddItem(Loc.GetString("comms-console-change-alert-level-button"));
        AlertLevelSelector.Select(0);

        if (alerts != null)
        {
            foreach (var alert in alerts)
            {
                AlertLevelSelector.AddItem(GetLocalizedAlertName(alert));
                AlertLevelSelector.SetItemMetadata(AlertLevelSelector.ItemCount - 1, alert);

                if (alert == previousSelection)
                {
                    AlertLevelSelector.Select(AlertLevelSelector.ItemCount - 1);
                }
            }
        }

        if (_loc.TryGetString($"comms-console-level-{currentAlert}-flavour-label", out var flavour))
        {
            CurrentAlertLevelFlavorLabel.Text = flavour;
        }
        else
        {
            CurrentAlertLevelFlavorLabel.Text = string.Empty;
        }

        EnableDisableConfirmLevelChangeButton();
    }

    /// <summary>
    /// Configure the "confirm alert level changed" button to be consistent with
    /// the server state and user interactions
    /// </summary>
    private void EnableDisableConfirmLevelChangeButton()
    {
        // Disable the button when:
        // 1. Server says we can't change level
        // 2. User selected special info option (id 0)
        // 3. User selected the same level the station is currently on
        var selectedId = AlertLevelSelector.SelectedId;
        ConfirmAlertLevelButton.Disabled = !_alertLevelSelectable || selectedId == 0;
        if (selectedId != 0)
        {
            var metadata = AlertLevelSelector.GetItemMetadata(selectedId);
            if (metadata is string selected)
            {
                ConfirmAlertLevelButton.Disabled |= selected == _currentAlertLevel;
            }
        }
    }

    /// <summary>
    /// Utility function to convert an alert level identifier into a localized string
    /// </summary>
    private string GetLocalizedAlertName(string alertName)
    {
        if (_loc.TryGetString($"alert-level-{alertName}", out var locName))
        {
            return locName;
        }
        return alertName;
    }
}
