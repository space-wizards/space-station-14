using System.Numerics;
using Content.Shared.CCVar;
using Content.Shared.Communications;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Configuration;
using Robust.Shared.Timing;
using Robust.Shared.Utility;

namespace Content.Client.Communications.UI
{
    [GenerateTypedNameReferences]
    public sealed partial class CommunicationsConsoleMenu : BaseWindow
    {
        [Dependency] private readonly IConfigurationManager _cfg = default!;
        [Dependency] private readonly IGameTiming _timing = default!;
        [Dependency] private readonly ILocalizationManager _loc = default!;
        private const int DRAG_MOVE_SIZE = 40;
        private const int DRAG_RESIZE_SIZE = 7;

        public bool CanAnnounce;
        public bool CanBroadcast;
        public bool CanCall;
        public bool AlertLevelSelectable;
        public bool CountdownStarted;
        public string CurrentLevel = string.Empty;
        public TimeSpan? CountdownEnd;

        public event Action? OnEmergencyLevel;
        public event Action<string>? OnAlertLevel;
        public event Action<string>? OnAnnounce;
        public event Action<string>? OnBroadcast;

        public CommunicationsConsoleMenu()
        {
            IoCManager.InjectDependencies(this);
            RobustXamlLoader.Load(this);

            CloseButton.OnPressed += _ => Close();

            MessageInput.Placeholder = new Rope.Leaf(_loc.GetString("comms-console-menu-announcement-placeholder"));

            var maxAnnounceLength = _cfg.GetCVar(CCVars.ChatMaxAnnouncementLength);
            MessageInput.OnTextChanged += (args) =>
            {
                if (args.Control.TextLength > maxAnnounceLength)
                {
                    AnnounceButton.Disabled = true;
                    AnnounceButton.ToolTip = Loc.GetString("comms-console-message-too-long");
                }
                else
                {
                    AnnounceButton.Disabled = !CanAnnounce;
                    AnnounceButton.ToolTip = null;

                }
            };

            AnnounceButton.OnPressed += _ => OnAnnounce?.Invoke(Rope.Collapse(MessageInput.TextRope));
            AnnounceButton.Disabled = !CanAnnounce;

            BroadcastButton.OnPressed += _ => OnBroadcast?.Invoke(Rope.Collapse(MessageInput.TextRope));
            BroadcastButton.Disabled = !CanBroadcast;

            AlertLevelButton.OnItemSelected += args =>
            {
                AlertLevelButton.Select(args.Id);
                EnableDisableConfirmLevelChangeButton();
            };

            ConfirmAlertLevelButton.OnPressed += _ =>
            {
                var metadata = AlertLevelButton.GetItemMetadata(AlertLevelButton.SelectedId);
                if (metadata != null && metadata is string cast)
                {
                    OnAlertLevel?.Invoke(cast);
                }
            };

            AlertLevelButton.Disabled = !AlertLevelSelectable;

            EmergencyShuttleCallButton.OnPressed += _ => OnEmergencyLevel?.Invoke();
            EmergencyShuttleRecallButton.OnPressed += _ => OnEmergencyLevel?.Invoke();
            EnableDisableShuttleCallingButtons();
        }

        /// <summary>
        /// Configure UI to be consistent with the input state
        /// </summary>
        public void UpdateState(CommunicationsConsoleInterfaceState commsState)
        {
            CanAnnounce = commsState.CanAnnounce;
            CanBroadcast = commsState.CanBroadcast;
            CanCall = commsState.CanCall;
            CountdownStarted = commsState.CountdownStarted;
            AlertLevelSelectable = commsState.AlertLevels != null && !float.IsNaN(commsState.CurrentAlertDelay) && commsState.CurrentAlertDelay <= 0;
            CurrentLevel = commsState.CurrentAlert;
            CountdownEnd = commsState.ExpectedCountdownEnd;

            UpdateAlertLevels(commsState.AlertLevels, CurrentLevel, commsState.CurrentAlertColor);
            EnableDisableShuttleCallingButtons();
            AnnounceButton.Disabled = !CanAnnounce;
            BroadcastButton.Disabled = !CanBroadcast;
        }

        protected override void FrameUpdate(FrameEventArgs args)
        {
            base.FrameUpdate(args);
            UpdateCountdown();
        }

        protected override void Draw(DrawingHandleScreen handle)
        {
            UpdateCountdown();
            base.Draw(handle);
        }

        protected override DragMode GetDragModeFor(Vector2 relativeMousePos)
        {
            if (relativeMousePos.Y < DRAG_MOVE_SIZE)
            {
                return DragMode.Move;
            }
            else
            {
                var mode = DragMode.None;

                if (relativeMousePos.Y > Size.Y - DRAG_RESIZE_SIZE)
                {
                    mode |= DragMode.Bottom;
                }

                if (relativeMousePos.X > Size.X - DRAG_RESIZE_SIZE)
                {
                    mode |= DragMode.Right;
                }
                return mode;
            }
        }

        // The current alert could make levels unselectable, so we need to ensure that the UI reacts properly.
        // If the current alert cannot be changed, the only item in the alerts list will be
        // the current alert. Otherwise, it will be the list of alerts.
        private void UpdateAlertLevels(List<string>? alerts, string currentAlert, Color currentAlertColor)
        {
            CurrentLevel = currentAlert;
            CurrentAlertLevelLabel.Text = GetLocalizedAlertName(currentAlert);
            CurrentAlertLevelLabel.ModulateSelfOverride = currentAlertColor;

            AlertLevelButton.Disabled = alerts == null || !AlertLevelSelectable;

            // If user has changed the selection when we get an update, try to remember what they had selected
            string? previousSelection = null;
            if (AlertLevelButton.ItemCount > 1)
            {
                var metadata = AlertLevelButton.GetItemMetadata(AlertLevelButton.SelectedId);
                if (metadata != null && metadata is string cast)
                {
                    previousSelection = cast;
                }
            }

            AlertLevelButton.Clear();
            AlertLevelButton.AddItem(Loc.GetString("comms-console-change-alert-level-button"));
            AlertLevelButton.Select(0);

            if (alerts != null)
            {
                foreach (var alert in alerts)
                {
                    AlertLevelButton.AddItem(GetLocalizedAlertName(alert));
                    AlertLevelButton.SetItemMetadata(AlertLevelButton.ItemCount - 1, alert);

                    if (alert == previousSelection)
                    {
                        AlertLevelButton.Select(AlertLevelButton.ItemCount - 1);
                    }
                }
            }

            if (_loc.TryGetString($"comms-console-level-{currentAlert}-flavour-label", out var flavour))
            {
                CurrentAlertLevelFlavorLabel.Text = flavour;
            }
            else
            {
                CurrentAlertLevelFlavorLabel.Text = string.Empty;
            }

            EnableDisableConfirmLevelChangeButton();
        }

        /// <summary>
        /// Syncs and animates the display of the time-to-shuttle-arrival label
        /// </summary>
        private void UpdateCountdown()
        {
            // Set the label on the LCD countdown
            var countdown = CountdownEnd == null ? 0.0f : (float)Math.Max(CountdownEnd.Value.Subtract(_timing.CurTime).TotalSeconds, 0);

            int remainingWholeSeconds = CountdownStarted ? (int)Math.Ceiling(countdown) : 0;
            var message = (remainingWholeSeconds / 60).ToString("D2") + ":" + (remainingWholeSeconds % 60).ToString("D2");
            CountdownLabel.Text = message;

            CountdownLabel.Visible = CountdownStarted;
            if(countdown == 0)
            {
                CountdownLabel.ModulateSelfOverride = Color.White;
            }
            else
            {
                // Blink the LCD
                var alpha = 1.0f;
                if (!_cfg.GetCVar(CCVars.ReducedMotion))
                {
                    var subSecondsRemaining = countdown - (float)Math.Floor(countdown);
                    var lightEnableBlend = SmoothStep(0.1f, 0.3f, subSecondsRemaining);
                    var lightDisableBlend = SmoothStep(0.9f, 0.95f, subSecondsRemaining);
                    alpha = lightEnableBlend - lightDisableBlend;
                }
                CountdownLabel.ModulateSelfOverride = new Color(1.0f, 1.0f, 1.0f, alpha);
            }
        }

        private float SmoothStep(float stepBegin, float stepEnd, float x)
        {
           if (x < stepBegin)
              return 0;

           if (x >= stepEnd)
              return 1;

           float fractionInStep = (x - stepBegin) / (stepEnd - stepBegin);
           return (3 * x * x) - (2 * x * x * x);
        }

        /// <summary>
        /// Utility function to convert an alert level identifier into a localized string
        /// </summary>
        private string GetLocalizedAlertName(string alertName)
        {
            if (_loc.TryGetString($"alert-level-{alertName}", out var locName))
            {
                return locName;
            }
            return alertName;
        }

        /// <summary>
        /// Configure the confirm alert level changed button to be consistent with
        /// the server state and user interactions
        /// </summary>
        private void EnableDisableConfirmLevelChangeButton()
        {
            // Disable the button when:
            // 1. Server says we can't change level
            // 2. User selected special info option (id 0)
            // 3. User selected the same level the station is currently on
            var selectedId = AlertLevelButton.SelectedId;
            ConfirmAlertLevelButton.Disabled = !AlertLevelSelectable || selectedId == 0;
            if (selectedId != 0)
            {
                var metadata = AlertLevelButton.GetItemMetadata(selectedId);
                if (metadata != null && metadata is string selected)
                {
                    ConfirmAlertLevelButton.Disabled |= selected == CurrentLevel;
                }
            }
        }

        /// <summary>
        /// Configure the shuttle call/recall buttons to have a consistent state
        /// </summary>
        private void EnableDisableShuttleCallingButtons()
        {
            EmergencyShuttleCallButton.Disabled = !(CanCall && !CountdownStarted);
            EmergencyShuttleRecallButton.Disabled = !(CanCall && CountdownStarted);
        }
    }
}
