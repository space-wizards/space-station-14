using System.Linq;
using System.Numerics;
using Content.Shared._DV.CartridgeLoader.Cartridges;
using Content.Shared.CCVar;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Client.UserInterface;
using Robust.Shared.Configuration;
using Robust.Shared.Timing;
using Content.Shared.Input;

namespace Content.Client._DV.CartridgeLoader.Cartridges;

[GenerateTypedNameReferences]
public sealed partial class NanoChatUiFragment : BoxContainer
{
    [Dependency] private readonly IGameTiming _timing = default!;
    [Dependency] private readonly IConfigurationManager _cfg = default!;

    private int _maxNameLength;
    private int _maxIdJobLength;
    private readonly NewChatPopup _newChatPopup;
    private readonly EditChatPopup _editChatPopup;
    private uint? _currentChat;
    private uint? _pendingChat;
    private uint _ownNumber;
    private bool _notificationsMuted;
    private bool _listNumber = true;
    private Dictionary<uint, NanoChatRecipient> _recipients = [];
    private Dictionary<uint, List<NanoChatMessage>> _messages = [];
    private HashSet<uint> _mutedChats = [];

    public event Action<NanoChatUiMessageType, uint?, string?, string?>? OnMessageSent;

    public NanoChatUiFragment()
    {
        IoCManager.InjectDependencies(this);
        RobustXamlLoader.Load(this);

        _maxNameLength = _cfg.GetCVar(CCVars.MaxNameLength);
        _maxIdJobLength = _cfg.GetCVar(CCVars.MaxIdJobLength);

        _newChatPopup = new(_maxNameLength, _maxIdJobLength);
        _editChatPopup = new(_maxNameLength, _maxIdJobLength);
        SetupEventHandlers();
    }

    private void SetupEventHandlers()
    {
        _newChatPopup.OnChatCreated += (number, name, job) =>
        {
            OnMessageSent?.Invoke(NanoChatUiMessageType.NewChat, number, name, job);
        };

        _editChatPopup.OnContactEdited += (number, name, job) =>
        {
            OnMessageSent?.Invoke(NanoChatUiMessageType.EditChat, number, name, job);
        };

        NewChatButton.OnPressed += _ =>
        {
            _newChatPopup.ClearInputs();
            _newChatPopup.OpenCentered();
        };

        MuteChatButton.OnPressed += _ =>
        {
            if (_currentChat is not uint currentChat)
                return;

            // Remove if muted, otherwise add
            if (!_mutedChats.Remove(currentChat))
                _mutedChats.Add(currentChat);

            UpdateMuteChatButton();
            OnMessageSent?.Invoke(NanoChatUiMessageType.ToggleMuteChat, currentChat, null, null);
        };

        MuteButton.OnPressed += _ =>
        {
            _notificationsMuted = !_notificationsMuted;
            UpdateMuteButton();
            OnMessageSent?.Invoke(NanoChatUiMessageType.ToggleMute, null, null, null);
        };

        MessageInput.OnKeyBindDown += args =>
        {
            if (args.Function == ContentKeyFunctions.NanoChatNavigateUpUnread)
                CycleChannel(CycleDirection.Up, true);
            else if (args.Function == ContentKeyFunctions.NanoChatNavigateDownUnread)
                CycleChannel(CycleDirection.Down, true);
            else if (args.Function == ContentKeyFunctions.NanoChatNavigateUp)
                CycleChannel(CycleDirection.Up, false);
            else if (args.Function == ContentKeyFunctions.NanoChatNavigateDown)
                CycleChannel(CycleDirection.Down, false);
        };
        MessageInput.OnTextChanged += args =>
        {
            var length = args.Text.Length;
            var isValid = !string.IsNullOrWhiteSpace(args.Text) &&
                          length <= NanoChatMessage.MaxContentLength &&
                          (_currentChat != null || _pendingChat != null);

            SendButton.Disabled = !isValid;

            // Show character count when over limit
            CharacterCount.Visible = length > NanoChatMessage.MaxContentLength;
            if (length > NanoChatMessage.MaxContentLength)
            {
                CharacterCount.Text = Loc.GetString("nano-chat-message-too-long",
                    ("current", length),
                    ("max", NanoChatMessage.MaxContentLength));
                CharacterCount.StyleClasses.Add("LabelDanger");
            }
        };

        LookupButton.OnPressed += _ => ToggleView();
        LookupView.OnStartChat += contact =>
        {
            if (OnMessageSent is { } handler)
            {
                handler(NanoChatUiMessageType.NewChat, contact.Number, contact.Name, contact.JobTitle);
                SelectChat(contact.Number);
                ToggleView();
            }
        };
        ListNumberButton.OnPressed += _ =>
        {
            _listNumber = !_listNumber;
            UpdateListNumber();
            OnMessageSent?.Invoke(NanoChatUiMessageType.ToggleListNumber, null, null, null);
        };

        MessageInput.OnTextEntered += _ => SendMessage();
        SendButton.OnPressed += _ => SendMessage();
        EditChatButton.OnPressed += _ => BeginEditChat();
        DeleteChatButton.OnPressed += _ => DeleteCurrentChat();
    }

    private void ToggleView()
    {
        ChatView.Visible = !ChatView.Visible;
        LookupView.Visible = !ChatView.Visible;
        LookupButton.Pressed = LookupView.Visible;
    }

    public enum CycleDirection : byte
    {
        Up,
        Down,
    };

    private void CycleChannel(CycleDirection direction, bool onlyUnread)
    {
        if (_recipients.Count == 0)
            return;

        var orderedRecipients = _recipients.OrderBy(r => r.Value.Name).Select(r => r.Key).ToArray();
        var currentChatIndex = (direction, _currentChat) switch
        {
            (CycleDirection.Up, null) => _recipients.Count,
            (CycleDirection.Down, null) => 0,
            (_, uint currentChat) => Array.IndexOf(orderedRecipients, currentChat),
            _ => 0
        };
        var newChatIndex = currentChatIndex;

        do
        {
            newChatIndex = direction switch
            {
                CycleDirection.Up => newChatIndex - 1,
                CycleDirection.Down => newChatIndex + 1,
                _ => currentChatIndex,
            };
            if (newChatIndex < 0)
                newChatIndex = _recipients.Count - 1;
            else if (newChatIndex >= _recipients.Count)
                newChatIndex = 0;
        } while (onlyUnread && newChatIndex != currentChatIndex && !_recipients[orderedRecipients[newChatIndex]].HasUnread);

        SelectChat(orderedRecipients[newChatIndex]);
    }

    private void SendMessage()
    {
        var activeChat = _pendingChat ?? _currentChat;
        if (activeChat == null || string.IsNullOrWhiteSpace(MessageInput.Text))
            return;

        var messageContent = MessageInput.Text;
        if (!string.IsNullOrWhiteSpace(messageContent))
        {
            messageContent = messageContent.Trim();
            if (messageContent.Length > NanoChatMessage.MaxContentLength)
                messageContent = messageContent[..NanoChatMessage.MaxContentLength];
        }

        // Add predicted message
        var predictedMessage = new NanoChatMessage(
            _timing.CurTime,
            messageContent,
            _ownNumber
        );

        if (!_messages.TryGetValue(activeChat.Value, out var value))
        {
            value = new List<NanoChatMessage>();
            _messages[activeChat.Value] = value;
        }

        value.Add(predictedMessage);

        // Update UI with predicted message
        UpdateMessages(_messages);

        // Send message event
        OnMessageSent?.Invoke(NanoChatUiMessageType.SendMessage, activeChat, messageContent, null);

        // Clear input
        MessageInput.Text = string.Empty;
        SendButton.Disabled = true;
    }

    private void SelectChat(uint number)
    {
        // Don't reselect the same chat
        if (_currentChat == number && _pendingChat == null)
            return;

        _pendingChat = number;

        // Predict marking messages as read
        if (_recipients.TryGetValue(number, out var recipient))
        {
            recipient.HasUnread = false;
            _recipients[number] = recipient;
            UpdateChatList(_recipients);
        }

        OnMessageSent?.Invoke(NanoChatUiMessageType.SelectChat, number, null, null);
        UpdateCurrentChat();
    }

    private void DeleteCurrentChat()
    {
        var activeChat = _pendingChat ?? _currentChat;
        if (activeChat == null)
            return;

        OnMessageSent?.Invoke(NanoChatUiMessageType.DeleteChat, activeChat, null, null);
    }

    private void BeginEditChat()
    {
        if (_currentChat is not uint currentChat)
            return;

        var recipient = _recipients[currentChat];

        _editChatPopup.ClearInputs();
        _editChatPopup.SetNumberInput(recipient.Number.ToString());
        _editChatPopup.SetNameInput(recipient.Name);
        _editChatPopup.SetJobInput(recipient.JobTitle ?? string.Empty);
        _editChatPopup.OpenCentered();
    }

    private void UpdateChatList(Dictionary<uint, NanoChatRecipient> recipients)
    {
        ChatList.RemoveAllChildren();
        _recipients = recipients;

        NoChatsLabel.Visible = recipients.Count == 0;
        if (NoChatsLabel.Parent != ChatList)
        {
            NoChatsLabel.Parent?.RemoveChild(NoChatsLabel);
            ChatList.AddChild(NoChatsLabel);
        }

        foreach (var (number, recipient) in recipients.OrderBy(r => r.Value.Name))
        {
            var entry = new NanoChatEntry(_maxNameLength, _maxIdJobLength);
            // For pending chat selection, always show it as selected even if unconfirmed
            var isSelected = (_pendingChat == number) || (_pendingChat == null && _currentChat == number);
            entry.SetRecipient(recipient, number, isSelected);
            entry.OnPressed += SelectChat;
            ChatList.AddChild(entry);
        }
    }

    private void UpdateCurrentChat()
    {
        var activeChat = _pendingChat ?? _currentChat;
        var hasActiveChat = activeChat != null;

        // Update UI state
        MessagesScroll.Visible = hasActiveChat;
        CurrentChatName.Visible = !hasActiveChat;
        MessageInputContainer.Visible = hasActiveChat;
        DeleteChatButton.Visible = hasActiveChat;
        EditChatButton.Visible = hasActiveChat;
        DeleteChatButton.Disabled = !hasActiveChat;

        if (activeChat != null && _recipients.TryGetValue(activeChat.Value, out var recipient))
        {
            CurrentChatName.Text = recipient.Name + (string.IsNullOrEmpty(recipient.JobTitle) ? "" : $" ({recipient.JobTitle})");
        }
        else
        {
            CurrentChatName.Text = Loc.GetString("nano-chat-select-chat");
        }
    }

    private void UpdateMessages(Dictionary<uint, List<NanoChatMessage>> messages)
    {
        _messages = messages;
        MessageList.RemoveAllChildren();

        var activeChat = _pendingChat ?? _currentChat;
        if (activeChat == null || !messages.TryGetValue(activeChat.Value, out var chatMessages))
            return;

        foreach (var message in chatMessages)
        {
            var messageBubble = new NanoChatMessageBubble();
            messageBubble.SetMessage(message, message.SenderId == _ownNumber);
            MessageList.AddChild(messageBubble);

            // Add spacing between messages
            MessageList.AddChild(new Control { MinSize = new Vector2(0, 4) });
        }

        MessageList.InvalidateMeasure();
        MessagesScroll.InvalidateMeasure();

        // Scroll to bottom after messages are added
        if (MessageList.Parent is ScrollContainer scroll)
            scroll.SetScrollValue(new Vector2(0, float.MaxValue));
    }

    private void UpdateMuteButton()
    {
        if (BellMutedIcon != null)
            BellMutedIcon.Visible = _notificationsMuted;
    }

    private void UpdateMuteChatButton()
    {
        if (BellMutedIconContact != null)
            BellMutedIconContact.Visible = _currentChat is uint currentChat && _mutedChats.Contains(currentChat);
    }

    private void UpdateListNumber()
    {
        if (ListNumberButton != null)
            ListNumberButton.Pressed = _listNumber;
    }

    public void UpdateState(NanoChatUiState state)
    {
        _ownNumber = state.OwnNumber;
        _notificationsMuted = state.NotificationsMuted;
        _listNumber = state.ListNumber;
        _mutedChats = state.MutedChats;
        OwnNumberLabel.Text = $"#{state.OwnNumber:D4}";
        UpdateMuteButton();
        UpdateListNumber();

        // Update new chat button state based on recipient limit
        var atLimit = state.Recipients.Count >= state.MaxRecipients;
        NewChatButton.Disabled = atLimit;
        NewChatButton.ToolTip = atLimit
            ? Loc.GetString("nano-chat-max-recipients")
            : Loc.GetString("nano-chat-new-chat");

        // First handle pending chat resolution if we have one
        if (_pendingChat != null)
        {
            if (_pendingChat == state.CurrentChat)
                _currentChat = _pendingChat; // Server confirmed our selection

            _pendingChat = null; // Clear pending either way
        }

        // No pending chat or it was just cleared, update current directly
        if (_pendingChat == null)
            _currentChat = state.CurrentChat;

        UpdateCurrentChat();
        UpdateMuteChatButton();
        UpdateChatList(state.Recipients);
        UpdateMessages(state.Messages);
        LookupView.UpdateContactList(state);
    }
}
