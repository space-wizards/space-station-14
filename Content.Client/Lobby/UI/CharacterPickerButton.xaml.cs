using System.Numerics;
using Content.Client.Stylesheets;
using Content.Shared.Preferences;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Player;
using Robust.Shared.Prototypes;

namespace Content.Client.Lobby.UI;

/// <summary>
/// Holds character data on the side of the setup GUI.
/// </summary>
[GenerateTypedNameReferences]
public sealed partial class CharacterPickerButton : ContainerButton
{
    const string EnabledLoc = "character-setup-gui-character-picker-button-enabled-button";
    const string DisabledLoc = "character-setup-gui-character-picker-button-disabled-button";

    /// <summary>
    /// Invoked if we should delete the attached character
    /// </summary>
    public event Action? OnDeletePressed;

    /// <summary>
    /// Invoked if we should enable or disable the attached character
    /// </summary>
    public event Action<bool>? OnEnableToggled;

    /// <summary>
    /// Create a new character picker button
    /// </summary>
    /// <param name="prefMan"></param>
    /// <param name="protoMan"></param>
    /// <param name="entMan"></param>
    /// <param name="playerMan"></param>
    /// <param name="group">Button group to join</param>
    /// <param name="profile">Profile this button is attached to</param>
    /// <param name="isSelected">If true, start in pressed state</param>
    /// <param name="simple">If true, don't show enable or delete button (used for late join gui)</param>
    public CharacterPickerButton(
        IClientPreferencesManager prefMan,
        IPrototypeManager protoMan,
        IEntityManager entMan,
        ISharedPlayerManager playerMan,
        ButtonGroup group,
        HumanoidCharacterProfile profile,
        bool isSelected,
        bool simple = false)
    {
        RobustXamlLoader.Load(this);
        AddStyleClass(StyleClassButton);
        ToggleMode = true;
        Group = group;

        View.Initialize(prefMan, protoMan, entMan, playerMan);
        View.LoadPreview(profile);

        EnabledCheck.Pressed = profile.Enabled;
        EnabledCheck.Text = Loc.GetString(profile.Enabled ? EnabledLoc : DisabledLoc);

        Pressed = isSelected;

        DescriptionLabel.Text = View.FullDescription;

        // Set up the StyleBoxTextures for the outlines...
        foreach (var panel in new List<PanelContainer>
                     { EnabledCheckOutline, DeleteButtonOutline, ConfirmDeleteButtonOutline })
        {
            if (panel.PanelOverride is not StyleBoxTexture styleBox)
                continue;
            styleBox.Texture = Theme.ResolveTexture("/Textures/Interface/Nano/slider_outline.svg.96dpi.png");
            styleBox.SetPatchMargin(StyleBox.Margin.All, 12);
            styleBox.SetContentMarginOverride(StyleBox.Margin.All, 0);
            styleBox.SetExpandMargin(StyleBox.Margin.All, 1);
            styleBox.TextureScale = new Vector2(1.1f);
            styleBox.Modulate = StyleNano.PanelDark;
        }

        if (simple)
        {
            ButtonDivider.Visible = false;
            ButtonBox.Visible = false;
        }
        else
        {
            AddStyleClass("OpenRight");
            DeleteButtonOutline.Visible = !isSelected;
            ConfirmDeleteButton.OnPressed += _ =>
            {
                Parent?.RemoveChild(this);
                Parent?.RemoveChild(ConfirmDeleteButton);
                OnDeletePressed?.Invoke();
            };

            DeleteButton.OnPressed += _ =>
            {
                DeleteButtonOutline.Visible = false;
                ConfirmDeleteButtonOutline.Visible = true;
            };

            EnabledCheck.OnToggled += args =>
            {
                OnEnableToggled?.Invoke(args.Pressed);
                EnabledCheck.Text = Loc.GetString(profile.Enabled ? EnabledLoc : DisabledLoc);
            };
        }
    }
}
