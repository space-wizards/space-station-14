using System.Linq;
using Content.Client.Lobby.UI.Roles;
using Content.Client.Stylesheets;
using Content.Shared.Preferences;
using Content.Shared.Traits;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;
using Robust.Shared.Utility;

namespace Content.Client.Lobby.UI.ProfileEditor.Tabs;

[GenerateTypedNameReferences]
public sealed partial class ProfileEditorTraitsTab : BoxContainer
{
    [Dependency] private readonly IPrototypeManager _prototypeManager = default!;

    public event Action<HumanoidCharacterProfile?>? OnTraitSelected;

    /// <summary>
    /// The work in progress profile being edited.
    /// </summary>
    private HumanoidCharacterProfile? _profile;

    public ProfileEditorTraitsTab()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
    }

    public void SetProfile(HumanoidCharacterProfile? profile)
    {
        _profile = profile;
        RefreshTraits();
    }

    /// <summary>
    /// Refreshes trait list, point counts, and categories
    /// </summary>
    public void RefreshTraits()
    {
        TraitsList.RemoveAllChildren();

        var traits = _prototypeManager.EnumeratePrototypes<TraitPrototype>()
            .OrderBy(t => Loc.GetString(t.Name));

        if (!traits.Any())
        {
            TraitsList.AddChild(new Label
            {
                Text = Loc.GetString("humanoid-profile-editor-no-traits"),
                FontColorOverride = Color.Gray,
            });
            return;
        }

        foreach (var (categoryId, categoryTraits) in GetTraitCategories(traits))
            CreateTraitCategory(categoryId, categoryTraits);
    }

    private Dictionary<string, List<TraitPrototype>> GetTraitCategories(IEnumerable<TraitPrototype> traits)
    {
        var traitCategories = new Dictionary<string, List<TraitPrototype>>();
        var defaultTraits = new List<TraitPrototype>();
        traitCategories.Add(TraitCategoryPrototype.Default, defaultTraits);

        foreach (var trait in traits)
        {
            if (trait.Category == null)
            {
                defaultTraits.Add(trait);
                continue;
            }

            if (!_prototypeManager.HasIndex(trait.Category))
                continue;

            var group = traitCategories.GetOrNew(trait.Category);
            group.Add(trait);
        }

        return traitCategories;
    }

    private void CreateTraitCategory(string id, List<TraitPrototype> traits)
    {
        TraitCategoryPrototype? category = null;

        if (id != TraitCategoryPrototype.Default)
        {
            category = _prototypeManager.Index<TraitCategoryPrototype>(id);
            TraitsList.AddChild(new Label
            {
                Text = Loc.GetString(category.Name),
                Margin = new Thickness(0, 10, 0, 0),
                StyleClasses = { StyleClass.LabelHeading },
            });
        }

        var traitSelectors = CreateSelectors(traits, out var selectionCount);

        if (category is { MaxTraitPoints: >= 0 })
        {
            TraitsList.AddChild(new Label
            {
                Text = Loc.GetString("humanoid-profile-editor-trait-count-hint",
                    ("current", selectionCount),
                    ("max", category.MaxTraitPoints)),
                FontColorOverride = Color.Gray
            });
        }

        foreach (var selector in traitSelectors)
        {
            if (category is { MaxTraitPoints: >= 0 } &&
                selector.Cost + selectionCount > category.MaxTraitPoints)
                selector.Checkbox.Label.FontColorOverride = Color.Red;

            TraitsList.AddChild(selector);
        }
    }

    private List<TraitPreferenceSelector> CreateSelectors(List<TraitPrototype> traits, out int selectionCount)
    {
        var selectors = new List<TraitPreferenceSelector>();
        selectionCount = 0;

        foreach (var trait in traits)
        {
            var selector = new TraitPreferenceSelector(trait)
            {
                Preference = _profile?.TraitPreferences.Contains(trait.ID) == true
            };

            if (selector.Preference)
                selectionCount += trait.Cost;

            selector.PreferenceChanged += selected => { SelectTrait(trait, selected); };
            selectors.Add(selector);
        }

        return selectors;
    }

    private void SelectTrait(TraitPrototype trait, bool selected)
    {
        if (selected)
            _profile = _profile?.WithTraitPreference(trait.ID, _prototypeManager);
        else
            _profile = _profile?.WithoutTraitPreference(trait.ID, _prototypeManager);

        OnTraitSelected?.Invoke(_profile);
        RefreshTraits();
    }
}
