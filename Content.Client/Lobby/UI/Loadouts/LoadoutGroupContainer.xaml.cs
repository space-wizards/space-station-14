using Content.Shared.Clothing;
using Content.Shared.Preferences;
using Content.Shared.Preferences.Loadouts;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Player;
using Robust.Shared.Prototypes;
using System.Linq;

namespace Content.Client.Lobby.UI.Loadouts;

[GenerateTypedNameReferences]
public sealed partial class LoadoutGroupContainer : BoxContainer
{
    /// <summary>
    /// A dictionary that stores open groups
    /// </summary>
    private Dictionary<string, bool> _openedGroups = new();

    private readonly LoadoutGroupPrototype _groupProto;

    private Dictionary<ProtoId<LoadoutGroupPrototype>, bool> LoadoutGroups = new Dictionary<ProtoId<LoadoutGroupPrototype>, bool>();

    public event Action<ProtoId<LoadoutPrototype>>? OnLoadoutPressed;
    public event Action<ProtoId<LoadoutPrototype>>? OnLoadoutUnpressed;

    public LoadoutGroupContainer(HumanoidCharacterProfile profile, RoleLoadout loadout, LoadoutGroupPrototype groupProto, ICommonSession session, IDependencyCollection collection)
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        _groupProto = groupProto;

        SetupGroups(_groupProto.LoadoutGroups);
        RefreshLoadouts(profile, loadout, session, collection);
    }

    public void SetupGroups(List<ProtoId<LoadoutGroupPrototype>> groups)
    {
        foreach (var group in groups)
        {
            LoadoutGroups.Add(group, false);
        }
    }

    /// <summary>
    /// Updates button availabilities and buttons.
    /// </summary>
    public void RefreshLoadouts(HumanoidCharacterProfile profile, RoleLoadout loadout, ICommonSession session, IDependencyCollection collection)
    {
        var protoMan = collection.Resolve<IPrototypeManager>();
        var loadoutSystem = collection.Resolve<IEntityManager>().System<LoadoutSystem>();
        var localizationMan = collection.Resolve<ILocalizationManager>();
        RestrictionsContainer.RemoveAllChildren();

        if (_groupProto.MinLimit > 0)
        {
            RestrictionsContainer.AddChild(new Label()
            {
                Text = Loc.GetString("loadouts-min-limit", ("count", _groupProto.MinLimit)),
                Margin = new Thickness(5, 0, 5, 5),
            });
        }

        if (_groupProto.MaxLimit > 0)
        {
            RestrictionsContainer.AddChild(new Label()
            {
                Text = Loc.GetString("loadouts-max-limit", ("count", _groupProto.MaxLimit)),
                Margin = new Thickness(5, 0, 5, 5),
            });
        }

        if (protoMan.Resolve(loadout.Role, out var roleProto) && roleProto.Points != null && loadout.Points != null)
        {
            RestrictionsContainer.AddChild(new Label()
            {
                Text = Loc.GetString("loadouts-points-limit", ("count", loadout.Points.Value), ("max", roleProto.Points.Value)),
                Margin = new Thickness(5, 0, 5, 5),
            });
        }

        SelectedCountLabel.Text = loadout.SelectedLoadouts[_groupProto.ID].Count().ToString();

        LoadoutsContainer.RemoveAllChildren();

        // Get all loadout prototypes for this group.
        var validProtos = _groupProto.Loadouts.Select(id => protoMan.Index(id));

        foreach (var group in LoadoutGroups.Keys)
        {
            if (!protoMan.TryIndex(group, out var loadoutGroupProto))
                continue;

            var groupProtos = loadoutGroupProto.Loadouts.Select(id => protoMan.Index(id));

            var uiElements = groupProtos
                .Select(proto =>
                {
                    var elem = CreateLoadoutUI(proto, profile, loadout, session, collection, loadoutSystem);
                    elem.HorizontalExpand = true;
                    return elem;
                })
                .ToList();

            var fallbackProto = groupProtos.First();
            var displayDummy = loadoutGroupProto.DummyEntity ?? fallbackProto.DummyEntity ?? loadoutSystem.GetFirstOrNull(fallbackProto);

            var subContainer = new SubLoadoutContainer()
            {
                Visible = LoadoutGroups[group]
            };
            var header = CreateSubLoadoutHeader(localizationMan.GetString(loadoutGroupProto.Name),"", displayDummy, subContainer, group);
            header.HorizontalExpand = true;

            header.SelectedCount = uiElements.Count(e => e.Select.Pressed).ToString();

            LoadoutsContainer.AddChild(header);
            LoadoutsContainer.AddChild(subContainer);

            var subList = subContainer.Grid;
            foreach (var proto in uiElements)
            {
                subList.AddChild(proto);
            }
        }

        foreach (var loadoutProto in validProtos)
        {
            LoadoutsContainer.AddChild(
                CreateLoadoutUI(loadoutProto, profile, loadout, session, collection, loadoutSystem)
            );
        }
    }

    private SubLoadoutHeader CreateSubLoadoutHeader(string displayName, string displayDescription, EntProtoId? displayDummy, SubLoadoutContainer subContainer, ProtoId<LoadoutGroupPrototype> groupKey)
    {
        var header = new SubLoadoutHeader(displayName, displayDescription, displayDummy);

        header.SetExpanded(subContainer.Visible);

        header.Button.OnPressed += _ =>
        {
            var willOpen = !subContainer.Visible;
            subContainer.Visible = willOpen;
            LoadoutGroups[groupKey] = willOpen;
            header.SetExpanded(willOpen);
        };

        return header;
    }

    private void UpdateSubGroupSelectedInfo(LoadoutContainer loadout, string itemName, BoxContainer subList)
    {
        var countSubSelected = subList.Children
            .OfType<LoadoutContainer>()
            .Count(c => c.Select.Pressed);

        if (countSubSelected > 0)
        {
            loadout.Text = Loc.GetString("loadouts-count-items-in-group", ("item", itemName), ("count", countSubSelected));
        }
    }

    /// <summary>
    /// Creates a UI container for a single Loadout item.
    ///
    /// This method was extracted from RefreshLoadouts because the logic for creating
    /// individual loadout items is used multiple times inside that method, and duplicating
    /// the code made it harder to maintain.
    ///
    /// Logic:
    /// - Checks if the item is currently selected in the loadout.
    /// - Checks if the item is valid for selection (IsValid).
    /// - Creates a LoadoutContainer with the appropriate status (disabled / active).
    /// - Subscribes to button press events to handle selection and deselection.
    /// </summary>
    /// <param name="proto">The loadout item prototype.</param>
    /// <param name="profile">The humanoid character profile.</param>
    /// <param name="loadout">The current role loadout for the user.</param>
    /// <param name="session">The user's session.</param>
    /// <param name="collection">The dependency injection container.</param>
    /// <param name="loadoutSystem">The loadout system instance.</param>
    /// <returns>A fully initialized LoadoutContainer for UI display.</returns>
    private LoadoutContainer CreateLoadoutUI(LoadoutPrototype proto, HumanoidCharacterProfile profile, RoleLoadout loadout, ICommonSession session, IDependencyCollection collection, LoadoutSystem loadoutSystem)
    {
        var selected = loadout.SelectedLoadouts[_groupProto.ID];

        var pressed = selected.Any(e => e.Prototype == proto.ID);

        var enabled = loadout.IsValid(profile, session, proto.ID, collection, out var reason);

        var cont = new LoadoutContainer(proto, !enabled, reason);

        cont.Text = loadoutSystem.GetName(proto);

        cont.Select.Pressed = pressed;

        cont.Select.OnPressed += args =>
        {
            if (args.Button.Pressed)
                OnLoadoutPressed?.Invoke(proto.ID);
            else
                OnLoadoutUnpressed?.Invoke(proto.ID);
        };

        return cont;
    }
}
