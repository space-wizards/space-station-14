using Content.Client.UserInterface.Controls;
using Content.Shared.Administration;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.ContentPack;
using Robust.Shared.Input;
using Robust.Shared.Random;
using Robust.Shared.Timing;
using Robust.Shared.Utility;
using System.IO;
using static Robust.Client.UserInterface.Controls.BaseButton;
using Range = Robust.Client.UserInterface.Controls.Range;

namespace Content.Client.Instruments.UI;

[GenerateTypedNameReferences]
public sealed partial class FileMidiSource : InstrumentMidiSourceBase
{
    private static readonly ResPath UserMidiDirectory = new("/UserMidis/");

    [Dependency] private readonly IFileDialogManager _dialogs = default!;
    [Dependency] private readonly IResourceManager _resManager = default!;
    [Dependency] private readonly IRobustRandom _random = default!;
    [Dependency] private readonly IUserInterfaceManager _userInterfaceManager = default!;

    private bool _isMidiFileDialogueWindowOpen;
    private DialogWindow? _reasonDialog;

    private bool IsShuffle => ShuffleButton.Pressed;
    private bool IsPlaying => PlayButton.Pressed;
    public override string ButtonName => Loc.GetString("instruments-component-menu-file-midi-source-button");

    private readonly string _noTrackSelectedText = Loc.GetString("instruments-component-menu-files-no-track-selected");

    public FileMidiSource()
    {
        RobustXamlLoader.Load(this);
        CurrentTrackLabel.Text = _noTrackSelectedText;
        AddButton.OnPressed += OnAddButtonPressed;
        TrackList.OnItemSelected += OnTrackListItemSelected;
        PlayButton.OnToggled += OnPlayButtonToggled;
        LoopButton.OnToggled += OnLoopButtonToggled;
        RemoveButton.OnPressed += OnRemoveButtonPressed;
        RenameButton.OnPressed += OnRenameButtonPressed;
        PlaybackSlider.OnValueChanged += OnPlaybackSliderValueChanged;
        PlaybackSlider.OnKeyBindUp += OnPlaybackSliderKeyBindUp;
    }

    protected override void VisibilityChanged(bool newVisible)
    {
        base.VisibilityChanged(newVisible);
        if (newVisible)
        {
            LoadUserMidis();
        }
        else
        {
            PlayButton.Pressed = false;
            StopPlaying();
            CurrentTrackLabel.Text = _noTrackSelectedText;
        }
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        base.FrameUpdate(args);

        if (!EntManager.TryGetComponent(Entity, out InstrumentComponent? instrument))
            return;

        if (PlaybackSlider.Grabbed)
            return;

        if (!instrument.IsMidiOpen)
        {
            ResetTrackIndicators();
            PlaybackSlider.Disabled = true;
        }
        else if (instrument.IsRendererAlive)
        {
            PlaybackSlider.Disabled = false;
            PlaybackSlider.MaxValue = instrument.PlayerTotalTick;
            PlaybackSlider.SetValueWithoutEvent(instrument.PlayerTick);
            // TODO: SequencerTimeScale does not return the actual ticks/seconds, find solution.
            var totalTime = TimeSpan.FromSeconds(Math.Ceiling(instrument.PlayerTotalTick / instrument.Renderer!.SequencerTimeScale));
            var currentTime = TimeSpan.FromSeconds(Math.Ceiling(instrument.PlayerTick / instrument.Renderer!.SequencerTimeScale));
            TimeLabel.Text = totalTime.Hours < 1
                ? $"{currentTime.Minutes:D2}:{currentTime.Seconds:D2}/{totalTime.Minutes:D2}:{totalTime.Seconds:D2}"
                : $"{currentTime.Hours:D2}:{currentTime.Minutes:D2}:{currentTime.Seconds:D2}/{totalTime.Hours:D2}:{totalTime.Minutes:D2}:{totalTime.Seconds:D2}";
        }
    }

    private void OnPlaybackSliderKeyBindUp(GUIBoundKeyEventArgs obj)
    {
        if (obj.Function != EngineKeyFunctions.UIClick)
            return;

        EntManager.System<InstrumentSystem>().SetPlayerTick(Entity, (int)Math.Ceiling(PlaybackSlider.Value));
    }

    private void OnPlaybackSliderValueChanged(Range _)
    {
        // Do not seek while still grabbing.
        if (PlaybackSlider.Grabbed)
            return;

        EntManager.System<InstrumentSystem>().SetPlayerTick(Entity, (int)Math.Ceiling(PlaybackSlider.Value));
    }

    private void OnRenameButtonPressed(ButtonEventArgs obj)
    {
        if (_reasonDialog != null)
        {
            _reasonDialog.MoveToFront();
            return;
        }

        if (!TrackList.GetSelected().TryFirstOrDefault(out var item))
            return;

        var originalName = item.Text;

        if (originalName == null)
            return;

        const string field = "name";
        const string placeholder = "";
        var title = Loc.GetString("instruments-component-menu-files-rename-dialog-title");
        var prompt = Loc.GetString("instruments-component-menu-files-rename-dialog-prompt");
        var entry = new QuickDialogEntry(field, QuickDialogEntryType.ShortText, prompt, placeholder);
        var entries = new List<QuickDialogEntry> { entry };
        _reasonDialog = new DialogWindow(title, entries);

        _reasonDialog.OnConfirmed += responses =>
        {
            var newName = responses[field];
            if (newName.Length < 1)
                return;
            if (!newName.EndsWith(".midi") && !newName.EndsWith(".mid"))
                newName += ".midi";
            RenameMidi(originalName, newName);
            item.Text = newName;
        };

        _reasonDialog.OnClose += () => { _reasonDialog = null; };
    }

    private void OnRemoveButtonPressed(ButtonEventArgs obj)
    {
        if (!TrackList.GetSelected().TryFirstOrDefault(out var item) || item.Text is not { Length: > 0 })
            return;

        DeleteMidi(item.Text);
        TrackList.Remove(item);
    }

    private void OnLoopButtonToggled(ButtonToggledEventArgs obj)
    {
        var instrument = EntManager.System<InstrumentSystem>();

        if (EntManager.TryGetComponent(Entity, out InstrumentComponent? instrumentComp))
        {
            instrumentComp.LoopMidi = obj.Pressed;
        }

        instrument.UpdateRenderer(Entity);
    }

    private void OnPlayButtonToggled(ButtonToggledEventArgs obj)
    {
        if (PlayButton.Pressed)
        {
            if (TrackList.GetSelected().TryFirstOrDefault(out var track))
            {
                PlayTrack((byte[])track.Metadata!);
            }
        }
        else
        {
            StopPlaying();
        }
    }

    private void OnTrackListItemSelected(ItemList.ItemListSelectedEventArgs obj)
    {
        var currentItem = obj.ItemList[obj.ItemIndex];
        CurrentTrackLabel.Text = currentItem.Text;
        if (IsPlaying)
        {
            PlayTrack((byte[])currentItem.Metadata!);
        }
    }

    private async void OnAddButtonPressed(ButtonEventArgs obj)
    {
        try
        {
            if (_isMidiFileDialogueWindowOpen)
                return;

            var filters = new FileDialogFilters(new FileDialogFilters.Group("mid", "midi"));

            // TODO: Once the file dialogue manager can handle focusing or closing windows, improve this logic to close
            // or focus the previously-opened window.
            _isMidiFileDialogueWindowOpen = true;

            await using var file = await _dialogs.OpenFile(filters, FileAccess.Read);

            _isMidiFileDialogueWindowOpen = false;

            // did the instrument menu get closed while waiting for the user to select a file?
            if (Disposed)
                return;

            if (file == null)
                return;

            var fileName = DateTime.Now.Ticks.ToString();
            StoreMidi(file.CopyToArray(), fileName + ".midi");
            TrackList.AddItem(fileName, null, true, file.CopyToArray());
        }
        catch
        {
            _userInterfaceManager.Popup(Loc.GetString("instruments-component-menu-files-error"));
        }
    }

    private void StopPlaying()
    {
        if (!EntManager.TryGetComponent<InstrumentComponent>(Entity, out var instrument))
            return;

        EntManager.System<InstrumentSystem>().CloseMidi(Entity, false, instrument);
        ResetTrackIndicators();
    }

    private void PlayTrack(byte[] trackData)
    {
        if (!PlayCheck())
            return;

        if (!EntManager.TryGetComponent<InstrumentComponent>(Entity, out var instrument))
            return;

        // Close any song that is already playing.
        if (instrument.IsMidiOpen)
            EntManager.System<InstrumentSystem>().CloseMidi(Entity, false, instrument);

        ResetTrackIndicators();

        Timer.Spawn(1000,
            () =>
        {
            if (!IsPlaying)
                return;

            if (!PlayCheck())
                return;

            if (!EntManager.System<InstrumentSystem>().OpenMidi(Entity, trackData, instrument))
                PlayButton.Pressed = false;
        });
    }

    private void LoadUserMidis()
    {
        TrackList.Clear();
        if (!_resManager.UserData.IsDir(UserMidiDirectory))
            return;

        foreach (var path in _resManager.UserData.DirectoryEntries(UserMidiDirectory))
        {
            try
            {
                var filePath = new ResPath(UserMidiDirectory + path);
                if (!filePath.Extension.Equals("midi") && !filePath.Extension.Equals("mid"))
                    continue;

                var data = _resManager.UserData.ReadAllBytes(filePath);
                TrackList.AddItem(filePath.Filename, null, true, data);
            }
            catch
            {
                // ignored
            }
        }
    }

    private void DeleteMidi(string name)
    {
        try
        {
            var path = new ResPath(UserMidiDirectory + name).Clean();
            _resManager.UserData.Delete(path);
        }
        catch
        {
            // ignored
        }
    }

    private void RenameMidi(string oldName, string newName)
    {
        try
        {
            EnsureMidiDirectoryExists();
            var oldPath = new ResPath(UserMidiDirectory + oldName);
            var newPath = new ResPath(UserMidiDirectory + newName);
            oldPath = oldPath.Clean();
            newPath = newPath.Clean();
            _resManager.UserData.Rename(oldPath, newPath);
        }
        catch
        {
            _userInterfaceManager.Popup(Loc.GetString("instruments-component-menu-files-error"));
        }
    }

    private void StoreMidi(byte[] data, string name)
    {
        try
        {
            EnsureMidiDirectoryExists();
            _resManager.UserData.WriteAllBytes(new ResPath(UserMidiDirectory + name + ".midi"), data);
        }
        catch
        {
            _userInterfaceManager.Popup(Loc.GetString("instruments-component-menu-files-error"));
        }
    }

    private void EnsureMidiDirectoryExists()
    {
        if (!_resManager.UserData.Exists(UserMidiDirectory))
            _resManager.UserData.CreateDir(UserMidiDirectory);
    }

    private void ResetTrackIndicators()
    {
        PlaybackSlider.MaxValue = 1;
        PlaybackSlider.SetValueWithoutEvent(0);
        TimeLabel.Text = "--.--/--.--";
    }

    public void PlayNextTrack()
    {
        // Only proceed if the play button is pressed.
        if (!IsPlaying)
            return;

        // Empty list, nothing to play.
        if (!TrackList.GetSelected().TryFirstOrDefault(out var item))
            return;

        if (IsShuffle)
        {
            TrackList[_random.Next(0, TrackList.Count)].Selected = true;
        }
        else
        {
            var idx = TrackList.IndexOf(item);
            if (idx != -1 && idx + 1 < TrackList.Count)
            {
                TrackList[idx + 1].Selected = true;
            }
            else
            {
                TrackList[0].Selected = true;
            }
        }
    }
}
