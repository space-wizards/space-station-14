using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Input;
using Robust.Shared.Random;
using Robust.Shared.Timing;
using Robust.Shared.Utility;
using static Robust.Client.UserInterface.Controls.BaseButton;
using Range = Robust.Client.UserInterface.Controls.Range;

namespace Content.Client.Instruments.UI;

[GenerateTypedNameReferences]
public sealed partial class FileMidiSource : InstrumentMidiSourceBase
{
    [Dependency] private readonly IEntityManager _entManager = default!;
    [Dependency] private readonly IRobustRandom _random = default!;

    public event Action<byte[]>? StartPlayingRequest;
    public event Action? StopPlayingRequest;
    public event Action<int>? TrackPositionChangeRequest;
    public event Action<string>? FileRenameRequest;
    public event Action<string>? FileRemoveRequest;
    public event Action? FileAddNewRequest;
    public event Action<bool>? LoopingToggled;

    private readonly string _noTrackSelectedText = Loc.GetString("instruments-component-menu-files-no-track-selected");
    private readonly Dictionary<string, byte[]> _loadedTracks = new();
    private EntityUid? _entity;

    private bool IsShuffle => ShuffleButton.Pressed;
    private string CurrentFilter => FilterBar.Text;
    public override string ButtonName => Loc.GetString("instruments-component-menu-file-midi-source-button");

    public bool IsPlaying
    {
        get => PlayButton.Pressed;
        set => PlayButton.Pressed = value;
    }

    public FileMidiSource()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        CurrentTrackLabel.Text = _noTrackSelectedText;
        FilterBar.OnTextChanged += OnFilterBarTextChanged;
        TrackList.OnItemSelected += OnTrackListItemSelected;
        AddButton.OnPressed += OnAddButtonPressed;
        RenameButton.OnPressed += OnRenameButtonPressed;
        RemoveButton.OnPressed += OnRemoveButtonPressed;
        PlayButton.OnToggled += OnPlayButtonToggled;
        LoopButton.OnToggled += OnLoopButtonToggled;
        PlaybackSlider.OnValueChanged += OnPlaybackSliderValueChanged;
        PlaybackSlider.OnKeyBindUp += OnPlaybackSliderKeyBindUp;
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        base.FrameUpdate(args);

        if (_entity == null)
            return;

        if (!_entManager.TryGetComponent(_entity, out InstrumentComponent? instrument))
            return;

        if (PlaybackSlider.Grabbed)
            return;

        if (!instrument.IsMidiOpen)
        {
            ResetTrackIndicators();
            PlaybackSlider.Disabled = true;
        }
        else if (instrument.IsRendererAlive)
        {
            PlaybackSlider.Disabled = false;
            PlaybackSlider.MaxValue = instrument.PlayerTotalTick;
            PlaybackSlider.SetValueWithoutEvent(instrument.PlayerTick);
            // TODO: SequencerTimeScale does not return the actual ticks/seconds, find solution.
            var totalTime = TimeSpan.FromSeconds(Math.Ceiling(instrument.PlayerTotalTick / instrument.Renderer!.SequencerTimeScale));
            var currentTime = TimeSpan.FromSeconds(Math.Ceiling(instrument.PlayerTick / instrument.Renderer!.SequencerTimeScale));
            TimeLabel.Text = totalTime.Hours < 1
                ? $"{currentTime.Minutes:D2}:{currentTime.Seconds:D2}/{totalTime.Minutes:D2}:{totalTime.Seconds:D2}"
                : $"{currentTime.Hours:D2}:{currentTime.Minutes:D2}:{currentTime.Seconds:D2}/{totalTime.Hours:D2}:{totalTime.Minutes:D2}:{totalTime.Seconds:D2}";
        }
    }

    public override void Disable()
    {
        base.Disable();
        TrackList.ClearSelected();
        IsPlaying = false;
        StopPlayingRequest?.Invoke();
        CurrentTrackLabel.Text = _noTrackSelectedText;
    }

    private void OnFilterBarTextChanged(LineEdit.LineEditEventArgs obj)
    {
        FilterTrackList();
    }

    private void OnTrackListItemSelected(ItemList.ItemListSelectedEventArgs obj)
    {
        var currentItem = obj.ItemList[obj.ItemIndex];
        CurrentTrackLabel.Text = currentItem.Text;
        if (IsPlaying)
        {
            StartPlaying((byte[])currentItem.Metadata!);
        }
    }

    private void OnAddButtonPressed(ButtonEventArgs obj)
    {
        FileAddNewRequest?.Invoke();
    }

    private void OnRenameButtonPressed(ButtonEventArgs obj)
    {
        if (!TrackList.GetSelected().TryFirstOrDefault(out var item) || item.Text is not { Length: > 0 })
            return;

        FileRenameRequest?.Invoke(item.Text);
    }

    private void OnRemoveButtonPressed(ButtonEventArgs obj)
    {
        if (!TrackList.GetSelected().TryFirstOrDefault(out var item) || item.Text is not { Length: > 0 })
            return;

        FileRemoveRequest?.Invoke(item.Text);
    }

    private void OnPlayButtonToggled(ButtonToggledEventArgs obj)
    {
        if (PlayButton.Pressed)
        {
            if (TrackList.GetSelected().TryFirstOrDefault(out var track))
            {
                StartPlaying((byte[])track.Metadata!);
            }
        }
        else
        {
            StopPlaying();
        }
    }

    private void OnLoopButtonToggled(ButtonToggledEventArgs obj)
    {
        LoopingToggled?.Invoke(LoopButton.Pressed);
    }

    private void OnPlaybackSliderValueChanged(Range _)
    {
        // Do not seek while still grabbing.
        if (PlaybackSlider.Grabbed)
            return;

        TrackPositionChangeRequest?.Invoke((int)Math.Ceiling(PlaybackSlider.Value));
    }

    private void OnPlaybackSliderKeyBindUp(GUIBoundKeyEventArgs obj)
    {
        if (obj.Function != EngineKeyFunctions.UIClick)
            return;

        TrackPositionChangeRequest?.Invoke((int)Math.Ceiling(PlaybackSlider.Value));
    }

    private void ResetTrackIndicators()
    {
        PlaybackSlider.MaxValue = 1;
        PlaybackSlider.SetValueWithoutEvent(0);
        TimeLabel.Text = "--.--/--.--";
    }

    private void StopPlaying()
    {
        StopPlayingRequest?.Invoke();
        ResetTrackIndicators();
    }

    private void StartPlaying(byte[] data)
    {
        StartPlayingRequest?.Invoke(data);
    }

    private void FilterTrackList()
    {
        var filterString = CurrentFilter.Trim().ToLowerInvariant();
        TrackList.Clear();

        foreach (var kv in _loadedTracks)
        {
            var trackName = kv.Key.Trim().ToLowerInvariant();
            if(trackName.Contains(filterString))
                TrackList.AddItem(kv.Key, null, true, kv.Value);
        }
    }

    public void SetEntity(EntityUid ent)
    {
        _entity = ent;
    }

    public void PopulateTrackList(IEnumerable<(string, byte[])> tracks)
    {
        _loadedTracks.Clear();
        foreach (var track in tracks)
        {
            _loadedTracks.Add(track.Item1, track.Item2);
        }

        FilterTrackList();
    }

    public void AddTrack(string name, byte[] data)
    {
        _loadedTracks.Add(name, data);
        FilterTrackList();
    }

    public void RemoveTrack(string name)
    {
        _loadedTracks.Remove(name);
        FilterTrackList();
    }

    public void UpdateTrackName(string originalName, string newName)
    {
        if (_loadedTracks.Remove(originalName, out var tempData))
            _loadedTracks.Add(newName, tempData);
        FilterTrackList();
    }

    public void PlayNextTrack()
    {
        // Only proceed if panel is visible.
        if (!Visible)
            return;

        // Only proceed if the play button is pressed.
        if (!IsPlaying)
            return;

        // Empty list, nothing to play.
        if (!TrackList.GetSelected().TryFirstOrDefault(out var item))
            return;

        if (IsShuffle)
        {
            TrackList[_random.Next(0, TrackList.Count)].Selected = true;
        }
        else
        {
            var idx = TrackList.IndexOf(item);
            if (idx != -1 && idx + 1 < TrackList.Count)
            {
                TrackList[idx + 1].Selected = true;
            }
            else
            {
                TrackList[0].Selected = true;
            }
        }
    }
}
