using Content.Client.UserInterface.Controls;
using Content.Shared.Administration;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.ContentPack;
using Robust.Shared.Input;
using Robust.Shared.Random;
using Robust.Shared.Timing;
using Robust.Shared.Utility;
using System.IO;
using static Robust.Client.UserInterface.Controls.BaseButton;
using Range = Robust.Client.UserInterface.Controls.Range;

namespace Content.Client.Instruments.UI;

[GenerateTypedNameReferences]
public sealed partial class FileMidiSource : InstrumentMidiSourceBase
{
    private static readonly ResPath UserMidiDirectory = new("/UserMidis/");

    [Dependency] private readonly IFileDialogManager _dialogs = default!;
    [Dependency] private readonly IResourceManager _resManager = default!;
    [Dependency] private readonly IRobustRandom _random = default!;

    private bool _isMidiFileDialogueWindowOpen = false;
    private DialogWindow? _reasonDialog;

    private bool IsShuffle => ShuffleButton.Pressed;
    private bool IsPlaying => PlayButton.Pressed;
    public override string ButtonName => Loc.GetString("instruments-component-menu-file-midi-source-button");

    private readonly string _noTrackSelectedText = Loc.GetString("instruments-component-menu-files-no-track-selected");

    public FileMidiSource() : base()
    {
        RobustXamlLoader.Load(this);
        CurrentTrackLabel.Text = _noTrackSelectedText;
        AddButton.OnPressed += OnAddButtonPressed;
        TrackList.OnItemSelected += OnTrackListItemSelected;
        PlayButton.OnToggled += OnPlayButtonToggled;
        LoopButton.OnToggled += OnLoopButtonToggled;
        RemoveButton.OnPressed += OnRemoveButtonPressed;
        RenameButton.OnPressed += OnRenameButtonPressed;
        PlaybackSlider.OnValueChanged += OnPlaybackSliderValueChanged;
        PlaybackSlider.OnKeyBindUp += OnPlaybackSliderKeyBindUp;
    }

    protected override void VisibilityChanged(bool newVisible)
    {
        base.VisibilityChanged(newVisible);
        if (newVisible)
        {
            LoadUserMidis();
        }
        else
        {
            PlayButton.Pressed = false;
            StopPlaying();
            CurrentTrackLabel.Text = _noTrackSelectedText;
        }
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        base.FrameUpdate(args);

        if (!EntManager.TryGetComponent(Entity, out InstrumentComponent? instrument))
            return;

        if (PlaybackSlider.Grabbed)
            return;

        if (!instrument.IsMidiOpen)
        {
            ResetTrackIndicators();
            PlaybackSlider.Disabled = true;
        }
        else if (instrument.IsRendererAlive)
        {
            PlaybackSlider.Disabled = false;
            PlaybackSlider.MaxValue = instrument.PlayerTotalTick;
            PlaybackSlider.SetValueWithoutEvent(instrument.PlayerTick);
            // TODO: SequencerTimeScale does not return the actual ticks/seconds, find solution.
            TimeSpan totalTime = TimeSpan.FromSeconds(Math.Ceiling(instrument.PlayerTotalTick / instrument.Renderer!.SequencerTimeScale));
            TimeSpan currentTime = TimeSpan.FromSeconds(Math.Ceiling(instrument.PlayerTick / instrument.Renderer!.SequencerTimeScale));
            if (totalTime.Hours < 1)
            {
                TimeLabel.Text = String.Format(
                    "{0:D2}:{1:D2}/{2:D2}:{3:D2}",
                    currentTime.Minutes,
                    currentTime.Seconds,
                    totalTime.Minutes,
                    totalTime.Seconds
                );
            }
            else
            {
                TimeLabel.Text = String.Format(
                    "{0:D2}:{1:D2}:{2:D2}/{3:D2}:{4:D2}:{5:D2}",
                    currentTime.Hours,
                    currentTime.Minutes,
                    currentTime.Seconds,
                    totalTime.Hours,
                    totalTime.Minutes,
                    totalTime.Seconds
                );
            }
        }
    }

    private void OnPlaybackSliderKeyBindUp(GUIBoundKeyEventArgs obj)
    {
        if (obj.Function != EngineKeyFunctions.UIClick)
            return;

        EntManager.System<InstrumentSystem>().SetPlayerTick(Entity, (int)Math.Ceiling(PlaybackSlider.Value));
    }

    private void OnPlaybackSliderValueChanged(Range _)
    {
        // Do not seek while still grabbing.
        if (PlaybackSlider.Grabbed)
            return;

        EntManager.System<InstrumentSystem>().SetPlayerTick(Entity, (int)Math.Ceiling(PlaybackSlider.Value));
    }

    private void OnRenameButtonPressed(ButtonEventArgs obj)
    {
        if (_reasonDialog != null)
        {
            _reasonDialog.MoveToFront();
            return;
        }

        if (!TrackList.GetSelected().TryFirstOrDefault(out var item))
            return;

        var originalName = item.Text;

        if (originalName == null)
            return;

        var field = "name";
        var title = Loc.GetString("instruments-component-menu-files-rename-dialog-title");
        var placeholder = "";
        var prompt = Loc.GetString("instruments-component-menu-files-rename-dialog-prompt");
        var entry = new QuickDialogEntry(field, QuickDialogEntryType.ShortText, prompt, placeholder);
        var entries = new List<QuickDialogEntry>() { entry };
        _reasonDialog = new DialogWindow(title, entries);

        _reasonDialog.OnConfirmed += responses =>
        {
            var newName = responses[field];
            if (newName.Length < 1)
                return;
            if (!newName.EndsWith(".midi") && !newName.EndsWith(".mid"))
                newName = newName + ".midi";
            RenameMidi(originalName, newName);
            item.Text = newName;
        };

        _reasonDialog.OnClose += () => { _reasonDialog = null; };
    }

    private void OnRemoveButtonPressed(ButtonEventArgs obj)
    {
        if (TrackList.GetSelected().TryFirstOrDefault(out var item) && item.Text != null && item.Text.Length > 0)
        {
            DeleteMidi(item.Text);
            TrackList.Remove(item);
        }
    }

    private void OnLoopButtonToggled(ButtonToggledEventArgs obj)
    {
        var instrument = EntManager.System<InstrumentSystem>();

        if (EntManager.TryGetComponent(Entity, out InstrumentComponent? instrumentComp))
        {
            instrumentComp.LoopMidi = obj.Pressed;
        }

        instrument.UpdateRenderer(Entity);
    }

    private void OnPlayButtonToggled(ButtonToggledEventArgs obj)
    {
        if (!EntManager.TryGetComponent<InstrumentComponent>(Entity, out var instrument))
            return;

        if (PlayButton.Pressed)
        {
            if (TrackList.GetSelected().TryFirstOrDefault(out var track))
            {
                PlayTrack((byte[])track.Metadata!);
            }
        }
        else
        {
            StopPlaying();
        }
    }

    private void OnTrackListItemSelected(ItemList.ItemListSelectedEventArgs obj)
    {
        var currentItem = obj.ItemList[obj.ItemIndex];
        CurrentTrackLabel.Text = currentItem.Text;
        if (IsPlaying)
        {
            PlayTrack((byte[])currentItem.Metadata!);
        }
    }

    private async void OnAddButtonPressed(ButtonEventArgs obj)
    {
        if (_isMidiFileDialogueWindowOpen)
            return;

        var filters = new FileDialogFilters(new FileDialogFilters.Group("mid", "midi"));

        // TODO: Once the file dialogue manager can handle focusing or closing windows, improve this logic to close
        // or focus the previously-opened window.
        _isMidiFileDialogueWindowOpen = true;

        await using var file = await _dialogs.OpenFile(filters, FileAccess.Read);

        _isMidiFileDialogueWindowOpen = false;

        // did the instrument menu get closed while waiting for the user to select a file?
        if (Disposed)
            return;

        if (file == null)
            return;

        if (!EntManager.TryGetComponent<InstrumentComponent>(Entity, out var instrument))
        {
            return;
        }

        string fileName = DateTime.Now.Ticks.ToString();
        StoreMidi(file.CopyToArray(), fileName + ".midi");
        TrackList.AddItem(fileName, null, true, file.CopyToArray());
    }

    private void StopPlaying()
    {
        if (!EntManager.TryGetComponent<InstrumentComponent>(Entity, out var instrument))
            return;

        EntManager.System<InstrumentSystem>().CloseMidi(Entity, false, instrument);
        ResetTrackIndicators();
    }

    private void PlayTrack(byte[] trackData)
    {
        if (!PlayCheck())
            return;

        if (!EntManager.TryGetComponent<InstrumentComponent>(Entity, out var instrument))
            return;

        // Close any song that is already playing.
        if (instrument.IsMidiOpen)
            EntManager.System<InstrumentSystem>().CloseMidi(Entity, false, instrument);

        ResetTrackIndicators();

        Timer.Spawn(1000, () =>
        {
            if (!IsPlaying)
                return;

            if (!PlayCheck())
                return;

            if (!EntManager.System<InstrumentSystem>().OpenMidi(Entity, trackData, instrument))
                PlayButton.Pressed = false;
        });
    }

    private void LoadUserMidis()
    {
        TrackList.Clear();
        if (_resManager.UserData.IsDir(UserMidiDirectory))
        {
            foreach (var path in _resManager.UserData.DirectoryEntries(UserMidiDirectory))
            {
                try
                {
                    ResPath filePath = new ResPath(UserMidiDirectory + path);
                    if (filePath.Extension.Equals("midi") || filePath.Extension.Equals("mid"))
                    {
                        byte[] data = _resManager.UserData.ReadAllBytes(filePath);
                        TrackList.AddItem(filePath.Filename, null, true, data);
                    }
                }
                catch
                {
                    continue;
                }
            }
        }
    }

    private void DeleteMidi(string name)
    {
        try
        {
            ResPath path = new ResPath(UserMidiDirectory + name).Clean();
            _resManager.UserData.Delete(path);
        }
        catch
        {
            return;
        }
    }

    private void RenameMidi(string oldName, string newName)
    {
        try
        {
            EnsureMidiDirectoryExists();
            ResPath oldPath = new ResPath(UserMidiDirectory + oldName);
            ResPath newPath = new ResPath(UserMidiDirectory + newName);
            oldPath = oldPath.Clean();
            newPath = newPath.Clean();
            _resManager.UserData.Rename(oldPath, newPath);
        }
        catch
        {
            return;
        }
    }

    private void StoreMidi(byte[] data, string name)
    {
        try
        {
            EnsureMidiDirectoryExists();
            _resManager.UserData.WriteAllBytes(new ResPath(UserMidiDirectory + name + ".midi"), data);
        }
        catch
        {
            return;
        }
    }

    private void EnsureMidiDirectoryExists()
    {
        if (!_resManager.UserData.Exists(UserMidiDirectory))
        {
            _resManager.UserData.CreateDir(UserMidiDirectory);
        }
    }

    private void ResetTrackIndicators()
    {
        PlaybackSlider.MaxValue = 1;
        PlaybackSlider.SetValueWithoutEvent(0);
        TimeLabel.Text = $"--.--/--.--";
    }

    public void PlayNextTrack()
    {
        // Only proceed if the play button is pressed.
        if (!IsPlaying)
            return;

        // Empty list, nothing to play.
        if (!TrackList.GetSelected().TryFirstOrDefault(out var item))
            return;

        if (IsShuffle)
        {
            TrackList[_random.Next(0, TrackList.Count)].Selected = true;
        }
        else
        {
            int idx = TrackList.IndexOf(item);
            if (idx != -1 && idx + 1 < TrackList.Count)
            {
                TrackList[idx + 1].Selected = true;
            }
            else
            {
                TrackList[0].Selected = true;
            }
        }
    }
}
