using Content.Client.Interactable;
using Content.Shared.ActionBlocker;
using Robust.Client.AutoGenerated;
using Robust.Client.Player;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Containers;

namespace Content.Client.Instruments.UI;

[GenerateTypedNameReferences]
public abstract partial class InstrumentMidiSourceBase : BoxContainer
{
    public virtual string ButtonName { get; } = "Unknown"; // CLEANUP, LOCALIZE

    [Dependency] protected readonly IEntityManager EntManager = default!;
    [Dependency] protected readonly IPlayerManager PlayerManager = default!;

    protected EntityUid Entity;

    public InstrumentMidiSourceBase()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
    }

    public virtual void SetInstrument(EntityUid entity)
    {
        Entity = entity;
    }

    public virtual void ClearInstrument()
    {
        Entity = EntityUid.Invalid;
    }

    protected bool PlayCheck()
    {
        if (!Entity.IsValid())
            return false;

        // TODO: Move this function into the shared instrument system as a seperate PR.
        if (!EntManager.TryGetComponent(Entity, out InstrumentComponent? instrument))
            return false;

        var localEntity = PlayerManager.LocalEntity;

        // If we don't have a player or controlled entity, we return.
        if (localEntity == null)
            return false;

        // By default, allow an instrument to play itself and skip all other checks
        if (localEntity == Entity)
            return true;

        var container = EntManager.System<SharedContainerSystem>();
        // If we're a handheld instrument, we might be in a container. Get it just in case.
        container.TryGetContainingContainer((Entity, null, null), out var conMan);

        // If the instrument is handheld and we're not holding it, we return.
        if (instrument.Handheld && (conMan == null || conMan.Owner != localEntity))
            return false;

        if (!EntManager.System<ActionBlockerSystem>().CanInteract(localEntity.Value, Entity))
            return false;

        // We check that we're in range unobstructed just in case.
        return EntManager.System<InteractionSystem>().InRangeUnobstructed(localEntity.Value, Entity);
    }
}
