using Content.Shared.Instruments;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.Graphics;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Audio.Midi;
using Robust.Shared.Utility;

namespace Content.Client.Instruments.UI;

[GenerateTypedNameReferences]
public sealed partial class ChannelsMenu : DefaultWindow
{
    [Dependency] private readonly IEntityManager _entityManager = default!;
    [Dependency] private readonly IResourceCache _resourceCache = default!;

    private readonly InstrumentBoundUserInterface _owner;

    private readonly TextureResource _texOn;
    private readonly TextureResource _texOff;

    public ChannelsMenu(InstrumentBoundUserInterface owner) : base()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        _owner = owner;

        ChannelList.OnItemSelected += OnItemSelected;
        ChannelList.OnItemDeselected += OnItemDeselected;
        AllButton.OnPressed += OnAllPressed;
        ClearButton.OnPressed += OnClearPressed;
        DisplayTrackNames.OnPressed += OnDisplayTrackNamesPressed;

        _texOn = _resourceCache.GetResource<TextureResource>("/Textures/Interface/Actions/channel-on.png");
        _texOff = _resourceCache.GetResource<TextureResource>("/Textures/Interface/Actions/channel-off.png");
    }

    protected override void EnteredTree()
    {
        base.EnteredTree();

        _owner.Instruments.OnChannelsUpdated += UpdateChannelList;

        var instrument = _entityManager.GetComponent<InstrumentComponent>(_owner.Owner);

        if (instrument.Renderer is not null)
            instrument.Renderer.OnMidiEvent += OnMidiEvent;
    }

    private void OnMidiEvent(RobustMidiEvent ev)
    {
        if (ev.MidiCommand == RobustMidiCommand.NoteOn)
        {
            if (ev.Data2 == 0)
                TurnChannelOff(ev.Channel);
            else
                TurnChannelOn(ev.Channel);
        }
        else if (ev.MidiCommand == RobustMidiCommand.NoteOff)
        {
            TurnChannelOff(ev.Channel);
        }
    }

    private void TurnChannelOn(int channel)
    {
        foreach (var item in ChannelList)
        {
            if ((byte)item.Metadata! == channel)
            {
                item.Icon = _texOn;
                item.IconModulate = Color.GreenYellow;
            }
        }
    }

    private void TurnChannelOff(int channel)
    {
        foreach (var item in ChannelList)
        {
            if ((byte)item.Metadata! == channel)
            {
                item.Icon = _texOff;
                item.IconModulate = Color.GreenYellow;
            }
        }
    }

    private void OnDisplayTrackNamesPressed(BaseButton.ButtonEventArgs obj)
    {
        DisplayTrackNames.SetClickPressed(!DisplayTrackNames.Pressed);
        Populate();
    }

    private void UpdateChannelList()
    {
        Populate(); // This is kind of in-efficent because we don't filter for which instrument updated its channels, but idc
    }

    protected override void ExitedTree()
    {
        base.ExitedTree();

        _owner.Instruments.OnChannelsUpdated -= UpdateChannelList;

        var instrument = _entityManager.GetComponent<InstrumentComponent>(_owner.Owner);

        if (instrument.Renderer is not null)
            instrument.Renderer.OnMidiEvent -= OnMidiEvent;
    }

    private void OnItemSelected(ItemList.ItemListSelectedEventArgs args)
    {
        _owner.Instruments.SetFilteredChannel(_owner.Owner, (byte)ChannelList[args.ItemIndex].Metadata!, false);
    }

    private void OnItemDeselected(ItemList.ItemListDeselectedEventArgs args)
    {
        _owner.Instruments.SetFilteredChannel(_owner.Owner, (byte)ChannelList[args.ItemIndex].Metadata!, true);
    }

    private void OnAllPressed(BaseButton.ButtonEventArgs obj)
    {
        foreach (var item in ChannelList)
        {
            // TODO: Make this efficient jfc
            item.Selected = true;
        }
    }

    private void OnClearPressed(BaseButton.ButtonEventArgs obj)
    {
        foreach (var item in ChannelList)
        {
            // TODO: Make this efficient jfc
            item.Selected = false;
        }
    }

    /// <summary>
    /// Walks up the tree of instrument masters to find the truest master of them all.
    /// </summary>
    private ActiveInstrumentComponent ResolveActiveInstrument(InstrumentComponent? comp)
    {
        comp ??= _entityManager.GetComponent<InstrumentComponent>(_owner.Owner);

        var instrument = new Entity<InstrumentComponent>(_owner.Owner, comp);

        while (true)
        {
            if (instrument.Comp.Master == null)
                break;

            instrument = new Entity<InstrumentComponent>((EntityUid)instrument.Comp.Master,
                _entityManager.GetComponent<InstrumentComponent>((EntityUid)instrument.Comp.Master));
        }

        return _entityManager.GetComponent<ActiveInstrumentComponent>(instrument.Owner);
    }

    public void Populate()
    {
        ChannelList.Clear();

        var instrument = _entityManager.GetComponent<InstrumentComponent>(_owner.Owner);
        var activeInstrument = ResolveActiveInstrument(instrument);

        Dictionary<byte, List<MidiTrack>> activeChannels = [];
        Dictionary<byte, string> channelNames = [];

        foreach (var track in activeInstrument.Tracks)
        {
            if (track is null)
                continue;

            foreach (var channel in track.Channels)
            {
                if (!activeChannels.ContainsKey(channel.Key))
                {
                    activeChannels.Add(channel.Key, []);
                    channelNames.Add(channel.Key, channel.Value);
                }

                activeChannels[channel.Key].Add(track);
            }
        }

        for (byte i = 0; i < RobustMidiEvent.MaxChannels; i++)
        {
            // Ignore channels that the MIDI doesn't play on.
            if (!activeChannels.TryGetValue(i, out var tracks))
                continue;

            var channelName = Loc.GetString("instruments-component-channels-single",
                ("channel", i),
                ("name", channelNames[i]));

            if (DisplayTrackNames.Pressed)
            {
                foreach (var track in tracks)
                {
                    if (track.TrackName is null)
                        continue;

                    if (track.InstrumentName is null)
                    {
                        channelName = Loc.GetString("instruments-component-channels-single",
                            ("channel", i),
                            ("name", track.TrackName));

                        break;
                    }

                    channelName = Loc.GetString("instruments-component-channels-multi",
                        ("channel", i),
                        ("name", track.TrackName),
                        ("other", track.InstrumentName));

                    break;
                }
            }

            var item = ChannelList.AddItem(channelName, _texOff.Texture, true, i);
            item.IconModulate = Color.GreenYellow;
            item.Selected = !instrument?.FilteredChannels[i] ?? false;
        }
    }
}
