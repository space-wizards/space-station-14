using Content.Shared.Instruments;
using Robust.Client.AutoGenerated;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Audio.Midi;

namespace Content.Client.Instruments.UI;

[GenerateTypedNameReferences]
public sealed partial class ChannelsMenu : DefaultWindow
{
    [Dependency] private readonly IEntityManager _entityManager = default!;
    [Dependency] private readonly IResourceCache _resourceCache = default!;

    private readonly InstrumentBoundUserInterface _owner;

    private readonly TextureResource _texOn;
    private readonly TextureResource _texOff;

    public ChannelsMenu(InstrumentBoundUserInterface owner)
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        _owner = owner;

        ChannelList.OnItemSelected += OnItemSelected;
        ChannelList.OnItemDeselected += OnItemDeselected;
        AllButton.OnPressed += OnAllPressed;
        ClearButton.OnPressed += OnClearPressed;
        DisplayTrackNames.OnPressed += OnDisplayTrackNamesPressed;

        _texOn = _resourceCache.GetResource<TextureResource>("/Textures/Interface/Actions/channel-on.png");
        _texOff = _resourceCache.GetResource<TextureResource>("/Textures/Interface/Actions/channel-off.png");
    }

    protected override void EnteredTree()
    {
        base.EnteredTree();

        _owner.Instruments.OnChannelsUpdated += UpdateChannelList;

        var instrument = _entityManager.GetComponent<InstrumentComponent>(_owner.Owner);

        if (instrument.Renderer is not null)
            instrument.Renderer.OnMidiEvent += OnMidiEvent;
    }

    private void OnMidiEvent(RobustMidiEvent ev)
    {
        switch (ev.MidiCommand)
        {
            case RobustMidiCommand.NoteOn when ev.Data2 == 0:
                TurnChannelOff(ev.Channel);
                break;
            case RobustMidiCommand.NoteOn:
                TurnChannelOn(ev.Channel);
                break;
            case RobustMidiCommand.NoteOff:
                TurnChannelOff(ev.Channel);
                break;
        }
    }

    private void TurnChannelOn(int channel)
    {
        foreach (var item in ChannelList)
        {
            if ((byte)item.Metadata! == channel)
                item.Icon = _texOn;
        }
    }

    private void TurnChannelOff(int channel)
    {
        foreach (var item in ChannelList)
        {
            if ((byte)item.Metadata! == channel)
                item.Icon = _texOff;
        }
    }

    private void OnDisplayTrackNamesPressed(BaseButton.ButtonEventArgs obj)
    {
        DisplayTrackNames.SetClickPressed(!DisplayTrackNames.Pressed);
        Populate();
    }

    private void UpdateChannelList()
    {
        Populate(); // This is kind of in-efficent because we don't filter for which instrument updated its channels, but idc
    }

    protected override void ExitedTree()
    {
        base.ExitedTree();

        _owner.Instruments.OnChannelsUpdated -= UpdateChannelList;

        var instrument = _entityManager.GetComponent<InstrumentComponent>(_owner.Owner);

        if (instrument.Renderer is not null)
            instrument.Renderer.OnMidiEvent -= OnMidiEvent;
    }

    private void OnItemSelected(ItemList.ItemListSelectedEventArgs args)
    {
        _owner.Instruments.SetFilteredChannel(_owner.Owner, (byte)ChannelList[args.ItemIndex].Metadata!, false);
    }

    private void OnItemDeselected(ItemList.ItemListDeselectedEventArgs args)
    {
        _owner.Instruments.SetFilteredChannel(_owner.Owner, (byte)ChannelList[args.ItemIndex].Metadata!, true);
    }

    private void OnAllPressed(BaseButton.ButtonEventArgs obj)
    {
        foreach (var item in ChannelList)
        {
            // TODO: Make this efficient jfc
            item.Selected = true;
        }
    }

    private void OnClearPressed(BaseButton.ButtonEventArgs obj)
    {
        foreach (var item in ChannelList)
        {
            // TODO: Make this efficient jfc
            item.Selected = false;
        }
    }

    /// <summary>
    /// Walks up the tree of instrument masters to find the truest master of them all.
    /// </summary>
    private ActiveInstrumentComponent ResolveActiveInstrument(InstrumentComponent? comp)
    {
        comp ??= _entityManager.GetComponent<InstrumentComponent>(_owner.Owner);

        var instrument = new Entity<InstrumentComponent>(_owner.Owner, comp);

        while (true)
        {
            if (instrument.Comp.Master == null)
                break;

            instrument = new Entity<InstrumentComponent>((EntityUid)instrument.Comp.Master,
                _entityManager.GetComponent<InstrumentComponent>((EntityUid)instrument.Comp.Master));
        }

        return _entityManager.GetComponent<ActiveInstrumentComponent>(instrument.Owner);
    }

    public void Populate()
    {
        ChannelList.Clear();

        var instrument = _entityManager.GetComponent<InstrumentComponent>(_owner.Owner);
        var activeInstrument = ResolveActiveInstrument(instrument);

        Dictionary<byte, List<MidiTrack>> activeChannels = [];
        Dictionary<byte, string> channelNames = [];

        foreach (var track in activeInstrument.Tracks)
        {
            if (track is null)
                continue;

            foreach (var channel in track.Channels)
            {
                // If the channel is the Percussion channel, the fact that percussion is or is not
                // playing is controlled by the Instrument, not this window. Ergo do not show it.
                // TODO: This is kinda limiting UX (a DAW can't disable percussion ever?).
                if (channel.Key == RobustMidiEvent.PercussionChannel)
                    continue;

                // If the active channels do not include the channel key...
                if (!activeChannels.TryGetValue(channel.Key, out var value))
                {
                    value = [];
                    activeChannels.Add(channel.Key, value);
                    channelNames.Add(channel.Key, channel.Value);
                }

                value.Add(track);
            }
        }

        for (byte i = 0; i < RobustMidiEvent.MaxChannels; i++)
        {
            // Ignore channels that the MIDI doesn't play on.
            if (!activeChannels.TryGetValue(i, out var tracks))
                continue;

            var channelName = Loc.GetString("instruments-component-channels-single",
                ("channel", i),
                ("name", channelNames[i]));

            if (DisplayTrackNames.Pressed)
            {
                foreach (var track in tracks)
                {
                    if (track.TrackName is null)
                        continue;

                    if (track.InstrumentName is null)
                    {
                        channelName = Loc.GetString("instruments-component-channels-single",
                            ("channel", i),
                            ("name", track.TrackName));

                        break;
                    }

                    channelName = Loc.GetString("instruments-component-channels-multi",
                        ("channel", i),
                        ("name", track.TrackName),
                        ("other", track.InstrumentName));

                    break;
                }
            }

            var item = ChannelList.AddItem(channelName, _texOff.Texture, true, i);
            item.Selected = !instrument?.FilteredChannels[i] ?? false;
        }
    }
}
