using Content.Client.UserInterface.Controls;
using Content.Shared.Chat;
using Content.Shared.Radio;
using Content.Shared.Silicons.Laws;
using Content.Shared.Silicons.Laws.Components;
using Content.Shared.Speech;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;

namespace Content.Client.Silicons.Laws.Ui;

[GenerateTypedNameReferences]
public sealed partial class SiliconLawMenu : FancyWindow
{
    [Dependency] private readonly EntityManager _entityManager = default!;
    [Dependency] private readonly IPrototypeManager _prototypeManager = default!;

    public SiliconLawMenu()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
    }

    public void UpdateState(EntityUid uid, SiliconLawBuiState state)
    {
        var muted = !_entityManager.TryGetComponent<SpeechComponent>(uid, out var speech) || speech.SpeechSounds is null;
        var laws = state.Laws;
        laws.Sort();

        if (muted)
        {
            UpdateLawDisplays(laws, []);
            return;
        }

        var chatChannels = new List<ChatChannelDescriptor>(1 + state.RadioChannels?.Count ?? 0)
        {
            ChatChannelDescriptor.Local
        };

        if (state.RadioChannels is null)
        {
            UpdateLawDisplays(laws, chatChannels);
            return;
        }

        foreach (var radioChannel in state.RadioChannels)
            if (_prototypeManager.Resolve(radioChannel, out var radioChannelProto))
                chatChannels.Add(ChatChannelDescriptor.Radio(radioChannelProto, radioChannel == SharedChatSystem.CommonChannel));

        UpdateLawDisplays(laws, chatChannels);
    }

    private void UpdateLawDisplays(List<SiliconLaw> laws, List<ChatChannelDescriptor> chatChannels, bool forceRedraw = false)
    {
        if (forceRedraw)
            RedrawLawDisplays(laws, chatChannels);
        else
            PatchLawDisplays(laws, chatChannels);
    }

    /// <summary>
    /// Base update UI variant. Clears old law displays and draws new.
    /// When in doubt - use this.
    /// </summary>
    private void RedrawLawDisplays(List<SiliconLaw> laws, List<ChatChannelDescriptor> chatChannels)
    {
        if (laws.Count == 0 && LawDisplayContainer.ChildCount == 0)
        {
            // Nothing to show and nothing to clear.
            return;
        }

        LawDisplayContainer.RemoveAllChildren();

        foreach (var law in laws)
            LawDisplayContainer.AddChild(new LawDisplay(law, chatChannels));
    }

    /// <summary>
    /// Optimized update UI variant.
    /// Calculates a net delta change and only redraws what needs to be redrawn.
    /// </summary>
    private void PatchLawDisplays(List<SiliconLaw> laws, List<ChatChannelDescriptor> chatChannels)
    {
        if (laws.Count == 0 && LawDisplayContainer.ChildCount == 0)
        {
            // Nothing to show and nothing to clear.
            return;
        }

        var lawsToSeekMatchFor = new List<SiliconLaw>(laws);
        var validLawDisplays = new Dictionary<SiliconLaw, LawDisplay>(LawDisplayContainer.ChildCount);
        var nonReusableControls = new List<Robust.Client.UserInterface.Control>(LawDisplayContainer.ChildCount);
        foreach (var lawDisplayContainerChild in LawDisplayContainer.Children)
        {
            if (lawDisplayContainerChild is not LawDisplay lawDisplay)
            {
                // Not a LawDisplay at all (what's it doing here?)
                nonReusableControls.Add(lawDisplayContainerChild);
                continue;
            }

            var foundMatch = false;
            foreach (var law in lawsToSeekMatchFor)
                if (law == lawDisplay.Law)
                {
                    // The LawDisplay we are looking for
                    validLawDisplays.Add(law, lawDisplay);
                    lawsToSeekMatchFor.Remove(law); // Stop searching among ones that we already found a match for.
                    foundMatch = true;
                    break;
                }

            if (foundMatch)
                continue;

            // Not the LawDisplay we are looking for
            nonReusableControls.Add(lawDisplayContainerChild);
        }

        foreach (var nonReusableControl in nonReusableControls)
            LawDisplayContainer.RemoveChild(nonReusableControl);

        for (var i = 0; i < laws.Count; i++)
        {
            var law = laws[i];

            if (validLawDisplays.TryGetValue(law, out var thisLawDisplay))
            {
                thisLawDisplay.UpdateStateLawButtons(chatChannels);
                thisLawDisplay.SetPositionInParent(i);
            }
            else
            {
                var control = new LawDisplay(law, chatChannels);

                LawDisplayContainer.AddChild(control);
                control.SetPositionInParent(i);
            }
        }
    }
}

/// <summary>
/// Helper record to contain RadioChannelPrototype. Can be Radio or Local (null prototype).
/// </summary>
public sealed record ChatChannelDescriptor(RadioChannelPrototype? RadioChannelPrototype, bool IsCommon)
{
    public static ChatChannelDescriptor Local => new(null, false);
    public static ChatChannelDescriptor Radio(RadioChannelPrototype rcp, bool isCommon) => new(rcp, isCommon);
    public string Caption => Loc.GetString(RadioChannelPrototype?.Name ?? "hud-chatbox-select-channel-Local");
    public Color Color => RadioChannelPrototype?.Color ?? Color.DarkGray;
    public string ChannelPrefix => $"{ChannelTypePrefix}{RadioChannelPrototype?.KeyCode ?? null}";
    private bool IsLocal => RadioChannelPrototype is null;
    private char? ChannelTypePrefix => IsLocal ? null : IsCommon ? SharedChatSystem.RadioCommonPrefix : SharedChatSystem.RadioChannelPrefix;
}